# 什么是幂等？  
幂等原先是数学中的一个概念，表示进行 1 次变换和进行 N 次变换产生的效果相同。  
当我们讨论接口的幂等性时一般是在说：以相同的请求调用这个接口一次和调用这个接口多次，对系统产生的影响是相同的。如果一个接口满足这个特性，那么我们就说这个接口是一个幂等接口。  

## 接口幂等和防止重复提交是一回事吗？  
严格来说，并不是。
* 幂等: 更多的是在重复请求已经发生，或是无法避免的情况下，采取一定的技术手段让这些重复请求不给系统带来副作用。
* 防止重复: 提交更多的是不让用户发起多次一样的请求。比如说用户在线购物下单时点了提交订单按钮，但是由于网络原因响应很慢，此时用户比较心急多次点击了订单提交按钮。 这种情况下就可能会造成多次下单。一般防止重复提交的方案有：将订单按钮置灰，跳转到结果页等。主要还是从客户端的角度来解决这个问题。
  
## 哪些情况下客户端是防止不了重复提交的？  
虽然可在客户端做一些防止接口重复提交的事（比如将订单按钮置灰，跳转到结果页等），但是如下情况依然客户端是很难控制接口重复提交到后台的，这也进一步表明了接口幂等和防止重复提交不是一回事以及后端接口保证接口幂等的必要性所在。
* 接口超时重试：接口可能会因为某些原因而调用失败，出于容错性考虑会加上失败重试的机制。如果接口调用一半，再次调用就会因为脏数据的存在而出现异常。
* 消息重复消费：在使用消息中间件来处理消息队列，且手动 ack 确认消息被正常消费时。如果消费者突然断开连接，那么已经执行了一半的消息会重新放回队列。被其他消费者重新消费时就会导致结果异常，如数据库重复数据，数据库数据冲突，资源重复等。
* 请求重发：网络抖动引发的 nginx 重发请求，造成重复调用；
  
## 什么是接口幂等？  
在 HTTP/1.1 中，对幂等性进行了定义。它描述了一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外），即第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。  
这里的副作用是不会对结果产生破坏或者产生不可预料的结果。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。  

对哪些类型的接口需要保证接口幂等？看下标准的 restful 请求，幂等情况是怎么样的：
* SELECT 查询操作 
  * GET：只是获取资源，对资源本身没有任何副作用，天然的幂等性。
  * HEAD：本质上和 GET 一样，获取头信息，主要是探活的作用，具有幂等性。
  * OPTIONS：获取当前 URL 所支持的方法，因此也是具有幂等性的。
* DELETE 删除操作
  * 如果是根据唯一值进行删除的，删除一次和多次执行效果都是一样的，即具有幂等性。
  * 带条件的删除则不一定满足幂等性，例如执行的是删除满足条件的前 X 个数据，再执行一次就会多删除数据。
* ADD/EDIT 操作
  * PUT：用于更新资源，有副作用，但是它应该满足幂等性，比如根据 id 更新数据，调用多次和 N 次的作用是相同的（根据业务需求而变）。不过执行累加操作的更新不是幂等的。
  * POST：用于添加新的资源，多次提交很可能产生副作用，比如订单提交，多次提交很可能产生多笔订单。

幂等性设计增加了服务端的逻辑复杂性和成本。根据实际业务场景具体分析，除了业务上的特殊要求外，一般情况下不需要引入的接口幂等性。  


# 常见的保证幂等的方式？  
来看下常见的保证幂等的方式。

## 数据库层面  
网上有很多悲观锁（for update）可以实现幂等的方案，其实悲观锁不能实现幂等，只能辅助处理并发场景。  

### 唯一ID/索引
针对的是插入操作。  
数据库唯一主键的实现主要是利用数据库中主键唯一约束的特性，一般来说唯一主键比较适用于“插入”时的幂等性，其能保证一张表中只能存在一条带该唯一主键的记录。使用数据库唯一主键完成幂等性时需要注意的是，该主键一般来说并不是使用数据库中自增主键，而是使用分布式 ID 充当主键，这样才能能保证在分布式环境下 ID 的全局唯一性。  
幂等处理的过程，说到底其实就是过滤一下已经收到的请求，当然，请求一定要有一个全局唯一的 ID 标记。然后，怎么判断请求是否之前收到过呢？把请求储存起来，收到请求时，先查下存储记录，记录存在就返回上次的结果，不存在就处理请求。  

### 去重表
去重表本质上也是一种唯一索引方案。这种方法适用于在业务中有唯一标的插入场景中，比如在以上的支付场景中，如果一个订单只会支付一次，所以订单 ID 可以作为唯一标识。这时，就可以建一张去重表，并且把唯一标识作为唯一索引，在实现时，把创建支付单据和写入去去重表，放在一个事务中，如果重复创建，数据库会抛出唯一约束异常，操作就会回滚。  

### 乐观锁（基于版本号或者时间戳）
针对更新操作。  
使用版本号或者时间戳这种方法适合在更新的场景中，比如要更新商品的名字，这时就可以在更新的接口中增加一个版本号，来做幂等  
```boolean updateGoodsName(int id, String newName, int version);```  
在实现时可以如下  
```sql
update goods set name=#{newName}, version=#{version} where id=#{id} and version<${version}
```  

### 状态机
本质上也是乐观锁，这种方法适合在有状态机流转的情况下，比如就会订单的创建和付款，订单的付款肯定是在之前，这时可以通过在设计状态字段时，使用 int 类型，并且通过值类型的大小来做幂等，比如订单的创建为 0，付款成功为 100。付款失败为 99 在做状态机更新时，就这可以这样控制  
```sql
update `order` set status=#{status} where id=#{id} and status<#{status}
```  

### 分布式锁
分布式锁实现幂等性的逻辑是，在每次执行方法之前判断，是否可以获取到分布式锁，如果可以，则表示为第一次执行方法，否则直接舍弃请求即可。需要注意的是分布式锁的 key 必须为业务的唯一标识，通常用 redis 分布式锁（SETNX）或者 zookeeper 来实现分布式锁。  
请求过来时，先去尝试获得分布式锁，如果获得成功，就执行业务逻辑，反之获取失败的话，就舍弃请求直接返回成功。  

### Token 机制
为每个请求生成一个唯一的 Token，并在服务端进行校验，一旦处理了对应的请求，就丢弃该 Token，避免重复处理。  
1. 服务端提供了发送 token 的接口。在分析业务的时候，哪些业务是存在幂等问题的，就必须在执行业务前，先去获取 token，服务器会把 token 保存到 redis 中。
2. 然后调用业务接口请求时，把 token 携带过去，一般放在请求头部。
3. 服务器判断 token 是否存在 redis 中，存在表示第一次请求，然后删除 token，继续执行业务。
4. 如果判断 token 不存在 redis 中，就表示是重复操作，直接返回重复标记给 client，这样就保证了业务代码，不被重复执行。

注意：最好设计为先删除 token，如果业务调用失败，就重新获取 token 再次请求。 可以在 redis 使用 lua 脚本完成这个操作  



参考链接：
* https://pdai.tech/md/spring/springboot/springboot-x-interface-mideng.html
* https://juejin.cn/post/7366981996621103155
* https://zhuanlan.zhihu.com/p/461083186
