## 什么是分布式锁
分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。通常生产中可以直接使用 Redis 或者 ZooKeeper，它们都支持了分布式锁的功能。  
* 互斥性: 任意时刻，只有一个客户端能持有锁。
* 锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。
* 可重入性：一个线程如果获取了锁之后,可以再次对其请求加锁。
* 高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。
* 安全性：锁只能被持有的客户端删除，不能被其他客户端删除

[Redis 分布式锁官网](https://redis.io/docs/manual/patterns/distributed-locks/)  

### 方案一：SETNX + EXPIRE
用 setnx 来抢锁，如果抢到之后，再用 expire 给锁设置一个过期时间，防止锁忘记了释放。  
SETNX 是 SET IF NOT EXISTS 的简写.日常命令格式是 SETNX key value，如果 key 不存在，则 SETNX 成功返回 1，如果这个 key 已经存在了，则返回 0。  
这个方案中，setnx 和 expire 两个命令分开了，不是原子操作。如果执行完 setnx 加锁，正要执行 expire 设置过期时间时，进程 crash 或者要重启维护了，锁就永不释放了。  

### 方案二：SETNX + value 值为（系统时间+过期时间）
为了解决方案一，发生异常锁得不到释放的场景，可以把过期时间放到 setnx 的 value 值里面。如果加锁失败，再拿出 value 值校验一下即可。  
更新时使用 CAS 保证只有一个会加锁成功。  
这个方案还有别的缺点：过期时间是客户端自己生成的（System.currentTimeMillis() 是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。  

### 方案三：使用 Lua 脚本(包含 SETNX + EXPIRE 两条指令)
针对方案一，还可以使用 Lua 脚本来保证原子性（包含 setnx 和 expire 两条指令）。  

### 方案四：SET 的扩展命令（SET EX PX NX）
还可以巧用 Redis 的 SET 指令扩展参数（`SET key value[EX seconds][PX milliseconds][NX|XX]`），它也是原子性的。  

### 方案五：SET EX PX NX  + 校验唯一随机值，再释放锁
既然锁可能被别的线程误删，那给 value 值设置一个标记当前线程唯一的随机数，在删除的时候，校验一下。  

### 方案六：开源框架：Redisson


### 方案七：多机实现的分布式锁 Redlock
前面六种方案都只是基于单机版的。其实 Redis 一般都是集群部署的：  

如果线程一在 Redis 的 master 节点上拿到了锁，但是加锁的 key 还没同步到 slave 节点。恰好这时，master 节点发生故障，一个 slave 节点就会升级为 master 节点。线程二就可以获取同个 key 的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。  

为了解决这个问题，Redis 提出一种高级的分布式锁算法：Redlock。Redlock 核心思想是：部署多个 Redis master，以保证它们不会同时宕掉。并且这些 master 节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个 master 实例上，是与在 Redis 单实例，使用相同方法来获取和释放锁。  

RedLock 的实现步骤：
1. 获取当前时间，以毫秒为单位。
2. 按顺序向 N 个 master 节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间（假设锁自动失效时间为 10 秒，则超时时间一般在 5-50 毫秒之间）。如果超时，跳过该 master 节点，尽快去尝试下一个 master 节点。
3. 客户端使用当前时间减去开始获取锁时间（即步骤 1 记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1 个节点）的 Redis master 节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。如果取到了锁，key 的真正有效时间就变了，需要减去获取锁所使用的时间。如果获取锁失败（没有在至少 N/2+1 个 master 实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的 master 节点上解锁（即便有些 master 节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。

简化下步骤就是：
* 按顺序向 N 个 master 节点请求加锁。
* 根据设置的超时时间来判断，是不是要跳过该 master 节点。
* 如果大于等于 N/2+1 个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功。
* 如果获取锁失败，解锁。


链接：https://juejin.cn/post/6936956908007850014  

