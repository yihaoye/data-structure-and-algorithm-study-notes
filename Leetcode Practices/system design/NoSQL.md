NoSQL 的全称是 Not Only SQL，也可以理解非关系型的数据库，是一种新型的数据库设计方式，不过它不是为了取代传统的关系型数据库而被设计的，它们分别代表了不同的数据库设计思路。  
  
## 以 MongoDB 为例
* 它是一个内存数据库，数据都是放在内存里面的。
* 对数据的操作大部分都在内存中，但 MongoDB 并不是单纯的内存数据库。
* MongoDB 是由 C++ 语言进行编写的，是一个基于分布式文件存储的开源数据库系统。
* 在高负载的情况下，添加更多的节点，可以保证服务器的性能。 
* MongoDB 旨为 WEB 应用提供可扩展的高性能数据存储解决方案。
* MongoDB 将数据存储为一个文档，将数据结构由键值（key => value）对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
* MongoDB 与 MySQL 对比，传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB 是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。集合对应关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。  
  
  
### MongoDB 的存储特点
在传统的关系型数据库中，数据是以表单为媒介进行存储的，每个表单均拥有纵向的列和横向的列。相比较 MySQL，MongoDB 以一种直观文档的方式来完成数据的存储。它很像 JavaScript 中定义的 JSON 格式，不过数据在存储的时候 MongoDB 数据库为文档增加了序列化操作，最终存进磁盘的其实是叫做 BSON 的格式，即 Binary-JSON。  
在数据库存放的数据中，有一种特殊的键值叫做主键，它用于唯一的标识表中的某一条记录。也就是说，一个表不能有多个主键，并且主键不能为空值。无论是 MongoDB 还是 MySQL，都存在着主键的定义。  
MongoDB 会充分使用系统内存作为缓存，这是一种非常优秀的特征。比如测试机的内存有 64G，在插入时，MongoDB 会尽可能地在内存快写不进去数据之后，再将数据持久化保存到硬盘上。  
MongoDB 的索引通过 B-Tree 实现。索引放在内存中，能够提升随机读写的性能，如果索引不能完全放在内存，一旦出现随机读写比较高的时候，就会频繁地进行磁盘交换，MongoDB 的性能就会急剧下降。  
  
### MongoDB 的应用场景
在另一方面，对于开发者来说，如果是因为业务需求或者是项目初始化阶段，而是导致数据具体格式无法明确定义的话，MongoDB 的这一鲜明特性就脱颖而出了。相比传统的关系型数据库，它非常容易被扩展，这也为写代码带来了极大的方便（对开发者十分友好）。不过 MongoDB 对数据之间事务关系支持比较弱，如果业务这一方面要求比较高的话，MongoDB 还是并不适合此类的应用。  
非关系型数据库（NoSQL），属于文档型数据库。先解释一下文档型数据库，即可以存放 xml、json、bson 类型系的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。数据结构由键值（key => value）对组成。  
  
### MongoDB 与 MySQL 的适用场景
MongoDB 的适用场景为：数据不是特别重要（例如通知，推送这些），数据表结构变化较为频繁，数据量特别大，数据的并发性特别高，数据结构比较特别（例如地图的位置坐标），又比如数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，自带了对 Map-Reduce 运算框架的支持（很方便进行数据的统计），这些情况下用 MongoDB，其他情况就还是用 MySQL，这样组合使用就可以达到最大的效率。  
1. 如果需要将 MongoDB 作为后端 DB 来代替 MySQL 使用，即这里 MySQL 与 MongoDB 属于平行级别，那么，这样的使用可能有以下几种情况的考量：
    * MongoDB 所负责部分以文档形式存储，能够有较好的代码亲和性，json 格式的直接写入方便（如日志之类）。
    * 从 data models 设计阶段就将原子性考虑于其中，无需事务之类的辅助。开发用如 nodejs 之类的语言来进行开发，对开发比较方便。
    * MongoDB 本身的 failover 机制，无需使用如 MHA 之类的方式实现。
2. 将 MongoDB 作为类似 Redis，Memcache 来做缓存 DB，为 MySQL 提供服务，或是后端日志收集分析。考虑到 MongoDB 属于 NoSQL 型数据库，SQL 语句与数据结构不如 MySQL 那么亲和，也会有很多时候将 MongoDB 做为辅助 MySQL 而使用的类似 Redis、Memcache 之类的缓存 DB。亦或是仅作日志收集分析。
    * MongoDB 有一个最大的缺点，就是它占用的空间很大，因为它属于典型空间换时间原则的类型。那么它的磁盘空间比普通数据库会浪费一些。
    * 另外一个就是在一定的时间后，所占空间会莫明其妙地增大，所以要定期把数据库做修复，定期重新做索引，这样会提升 MongoDB 的稳定性和效率，在最新的版本里，它已经在实现在线压缩，可以在后台执行 repair database 的一些操作，有助于解决这一问题。  
  
  
### MongoDB 缺点（主要是无事务机制）
* MongoDB 不支持事务操作（最主要的缺点）
* MongoDB 占用空间过大
* MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和 IT 运营都是个值得注意的地方  
  
注意：以上只针对旧版本，现版本的 MongoDB（从 4.0 开始）已支持多文档事务。  
  
### 其他例子
#### Redis
* 是一个纯粹的内存数据库（内存满了会发生删除数据或拒绝写入）。
* 持久化方式：Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。  
  
#### DynamoDB
* Key-Value 和 Document 的数据库。
* 比 MongoDB 安全性更高。
* 比 MongoDB 更方便（AWS 完全托管的，将用户从底层基础结构中解放出来，并且仅通过远程端点与数据库进行交互，用户使用 DynamoDB 时无需担心操作问题或关注其他硬件规定）。
* 费用比 MongoDB 昂贵。
* 支持的语言和工具没有 MongoDB 多、生态比 MongoDB 小。  
  
#### 列数据库
[列数据库 - 维基百科](https://zh.m.wikipedia.org/zh-hans/%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93)  
列式数据库（Column-oriented DBMS）是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。  
数据库以行、列的二维表的形式存储数据，但是却以一维字符串的方式存储，如下表：  

|RowId	|EmpId	|Lastname	|Firstname	|Salary |
|---   |---    |---         |---        |---    |
|001	|10	    |Smith	    |Joe	    |40000  |
|002	|12	    |Jones	    |Mary	    |50000  |
|003	|11	    |Johnson	|Cathy	    |44000  |
|004	|22	    |Jones	    |Bob	    |55000  |

这个简单的表包括员工编号 (EmpId)、姓名字段 (Lastname and Firstname) 及工资 (Salary).  
这个表存储在电脑的内存 (RAM) 和存储(硬盘)中。虽然内存和硬盘在机制上不同，电脑的操作系统是以同样的方式存储的。数据库必须把这个二维表存储在一系列一维的“字节”中，由操作系统写到内存或硬盘中。  
列式数据库把一列中的数据值串在一起存储起来，然后再存储下一列的数据，以此类推。  
```
10:001,12:002,11:003,22:004;
Smith:001,Jones:002,Johnson:003,Jones:004;
Joe:001,Mary:002,Cathy:003,Bob:004;
40000:001,50000:002,44000:003,55000:004; 
```  
行式数据库把一行中的数据值串在一起存储起来，然后再存储下一行的数据，以此类推。  
```
001:10,Smith,Joe,40000;
002:12,Jones,Mary,50000;
003:11,Johnson,Cathy,44000;
004:22,Jones,Bob,55000;
```  
这只是一个简化的说法。此外，partitioning, 索引, 缓存机制, 视图, 联机分析多维数据集, 以及诸如预写式日志和多版本并发控制此类的事务系统都在现实的应用环境中发挥作用。一般来说, 侧重于联机事务处理 (OLTP) 的系统更适用行式数据库, 而侧重于联机分析处理的系统就必须在行式数据库和列式数据库中找到适当得平衡。  
**因为硬盘寻址时间相较于计算机上其他部件的运行速度来说不是一般的慢，所以常用相同工作负载下的硬盘访问性能来比较行式数据库和列式数据库。通常，顺序读取数据要比随机访问更快。**  
1. 在只需要根据某几列来聚合数据的时候按列的数据组织方式更有效。因为这样只需要读取一部分数据，要比读取全部数据更快。
2. 当只需要修改某一列值的时候按列的数据组织方式更有效。因为可以直接找到某列数据并修改，而与行中的其他列无关。
3. 当需要某行的多列数据的时候按行的数据组织方式更有效。当行中数据不是太多的情况下一次硬盘寻址就可以获得该行的所有数据。
4. 在新增行数据的时候，如果各列都有值，那么按行的数据组织方式会更有效，因为只需要一次硬盘寻址就可以写入整行的全部数据。

<details>
<summary>Cassandra 权威指南</summary>  

> 在列数据库中，数据围绕列而非行来组织。这样，可以对某些应用的负载更加优化，特别是数据仓库和分析类应用，因为它们在计算时需要聚集大量的相似数据。列数据库（或说面向列的数据库）特别适合那些对大数据集进行查询的在线分析处理（OLAP）应用。  
> 为了优化磁盘空间和 IO 消耗的时间，在列数据库里，数据存储的工作方式有些许不同。例如，列数据库允许写一条记录时，只写很多列中的一列，并且只有这列会占用实际空间。这和 RDBMS 非常不同，在 RDBMS 里，空值也不是零开销的。你可以把 RDBMS 想象成一个工作表，每行的同一列都占用同样的空间，为了维持表格数据结构的形状，即使没有东西也要维护一个空值在那。这个模型对列数据库根本就不适用，因为没有“空”值存在。列数据可以想象成是标签：值可以是任意长的，并且列的名字和宽度都不做预设。  
> 列数据库经常要求数据的类型是一致的，这样可以更好地进行数据压缩。  
> 列数据库最早大约出现在 20 世纪 70 年代早期。Sybase IQ 就是最早的列数据库之一，很多年来，都只有商业的列数据库。  
> 不过，近几年的项目（主要是开源项目）才是这里讨论的 NoSQL 的一部分，这些数据库演进自基本的键—值存储，但拥有更为丰富的数据模型。可以把这些列数据库看做是多维的键值存储或哈希表，它们不仅支持简单直接的键值对，还允许使用“列族”这样的数据模型来帮助组织各列，提供更丰富的模型。这些列数据库包括 Google 的 BigTable、HBase、Hypertable 和 Cassandra。  
> Google 的 Bigtable 是现代列数据库的鼻祖。它是一个内部自用的系统，但是 Google 发表了几篇论文来介绍它的设计，后面所有讨论的列数据库的实现都紧随 Bigtable 的设计。就 Cassandra 而言，它也从 Bigtable 继承了一些关键理念。  
</details>

<details>
<summary>列式数据库与关系数据库</summary>  

https://aws.amazon.com/cn/nosql/columnar/  
> 关系数据库针对存储数据行进行了优化，通常用于事务性应用程序，而列式数据库针对快速检索数据列进行了优化，通常用于分析应用程序。适用于数据库表的列式存储是分析查询性能的一个重要组成部分，因为它极大地降低了整体磁盘 I/O 要求，并减少了需要从磁盘载入的数据量。  
> 与其他 NoSQL 数据库一样，列式数据库旨在利用低成本硬件的分布式群集进行横向扩展，进而提高吞吐量，从而使其适用于数据仓库和大数据处理。  
* AWS 上的列式数据库
  * Amazon Redshift
* Amazon EC2 或 Amazon EMR 上的列式数据库
  * Apache Cassandra
  * Apache HBase
</details>

[为什么列存储数据库读取速度会比传统的行数据库快](https://www.zhihu.com/question/29380943/answer/1755250021)  

<br/>

### 数据仓库与普通数据库的区别
* 数据库 (Database) 的特点是：
  * 相对复杂的表格结构，存储结构相对紧致，少冗余数据。
  * 读和写都有优化。
  * 相对简单的 read/write query，单次作用于相对的少量数据。
* 数据仓库 (Datawarehouse) 的特点是：
  * 相对简单的 (Denormalized) 表格结构，存储结构相对松散，多冗余数据。
  * 一般只是读优化。
  * 相对复杂的 read query，单次作用于相对大量的数据（历史数据）。

链接：https://www.zhihu.com/question/20623931/answer/750367153  

### 其他
数据量和性能的比较：当物理内存够用的时候，Redis > MongoDB > MySQL 。  
当物理内存不够用的时候，Redis 和 MongoDB 都会使用虚拟内存。  
MySQL 支持 join，MongoDB 没有 join（因为 MongoDB 这类数据库就是设计成单个数据记录是聚合的/Aggregation。MongoDB 中有一个 lookup 操作，可以做 join 查询，但是理想情况下，这个 lookup 操作应该不会经常使用，如果开发者需要经常使用它，那么开发者就使用了错误的数据库存储了，如果有相关联的数据，应该使用关系型数据库）（注意：前面仅针对旧版本 MongoDB，从版本 3.2 开始，MongoDB 已支持 left outer join）。  
  
参考链接：https://www.jianshu.com/p/ad8992223812  
