NoSQL 的全称是 Not Only SQL，也可以理解非关系型的数据库，是一种新型的数据库设计方式，不过它不是为了取代传统的关系型数据库而被设计的，它们分别代表了不同的数据库设计思路。  
  
## 以 MongoDB 为例
* 它是一个内存数据库，数据都是放在内存里面的。
* 对数据的操作大部分都在内存中，但 MongoDB 并不是单纯的内存数据库。
* MongoDB 是由 C++ 语言进行编写的，是一个基于分布式文件存储的开源数据库系统。
* 在高负载的情况下，添加更多的节点，可以保证服务器的性能。 
* MongoDB 旨为 WEB 应用提供可扩展的高性能数据存储解决方案。
* MongoDB 将数据存储为一个文档，将数据结构由键值（key => value）对组成。MongoDB 文档类似于 JSON 对象。字段值可以包含其他文档，数组及文档数组。
* MongoDB 与 MySQL 对比，传统的关系数据库一般由数据库（database）、表（table）、记录（record）三个层次概念组成，MongoDB 是由数据库（database）、集合（collection）、文档对象（document）三个层次组成。集合对应关系型数据库里的表，但是集合中没有列、行和关系概念，这体现了模式自由的特点。  
  
  
### MongoDB 的存储特点
在传统的关系型数据库中，数据是以表单为媒介进行存储的，每个表单均拥有纵向的列和横向的列。相比较 MySQL，MongoDB 以一种直观文档的方式来完成数据的存储。它很像 JavaScript 中定义的 JSON 格式，不过数据在存储的时候 MongoDB 数据库为文档增加了序列化操作，最终存进磁盘的其实是叫做 BSON 的格式，即 Binary-JSON。  
在数据库存放的数据中，有一种特殊的键值叫做主键，它用于唯一的标识表中的某一条记录。也就是说，一个表不能有多个主键，并且主键不能为空值。无论是 MongoDB 还是 MySQL，都存在着主键的定义。  
MongoDB 会充分使用系统内存作为缓存，这是一种非常优秀的特征。比如测试机的内存有 64G，在插入时，MongoDB 会尽可能地在内存快写不进去数据之后，再将数据持久化保存到硬盘上。  
MongoDB 的索引通过 B-Tree 实现。索引放在内存中，能够提升随机读写的性能，如果索引不能完全放在内存，一旦出现随机读写比较高的时候，就会频繁地进行磁盘交换，MongoDB 的性能就会急剧下降。  
  
### MongoDB 的应用场景
在另一方面，对于开发者来说，如果是因为业务需求或者是项目初始化阶段，而是导致数据具体格式无法明确定义的话，MongoDB 的这一鲜明特性就脱颖而出了。相比传统的关系型数据库，它非常容易被扩展，这也为写代码带来了极大的方便（对开发者十分友好）。不过 MongoDB 对数据之间事务关系支持比较弱，如果业务这一方面要求比较高的话，MongoDB 还是并不适合此类的应用。  
非关系型数据库（NoSQL），属于文档型数据库。先解释一下文档型数据库，即可以存放 xml、json、bson 类型系的数据。这些数据具备自述性（self-describing），呈现分层的树状数据结构。数据结构由键值（key => value）对组成。  
  
### MongoDB 与 MySQL 的适用场景
MongoDB 的适用场景为：数据不是特别重要（例如通知，推送这些），数据表结构变化较为频繁，数据量特别大，数据的并发性特别高，数据结构比较特别（例如地图的位置坐标），又比如数据库具体数据格式不明确或者数据库数据格式经常变化的需求模型，自带了对 Map-Reduce 运算框架的支持（很方便进行数据的统计），这些情况下用 MongoDB，其他情况就还是用 MySQL，这样组合使用就可以达到最大的效率。  
1. 如果需要将 MongoDB 作为后端 DB 来代替 MySQL 使用，即这里 MySQL 与 MongoDB 属于平行级别，那么，这样的使用可能有以下几种情况的考量：
    * MongoDB 所负责部分以文档形式存储，能够有较好的代码亲和性，json 格式的直接写入方便（如日志之类）。
    * 从 data models 设计阶段就将原子性考虑于其中，无需事务之类的辅助。开发用如 nodejs 之类的语言来进行开发，对开发比较方便。
    * MongoDB 本身的 failover 机制，无需使用如 MHA 之类的方式实现。
2. 将 MongoDB 作为类似 Redis，Memcache 来做缓存 DB，为 MySQL 提供服务，或是后端日志收集分析。考虑到 MongoDB 属于 NoSQL 型数据库，SQL 语句与数据结构不如 MySQL 那么亲和，也会有很多时候将 MongoDB 做为辅助 MySQL 而使用的类似 Redis、Memcache 之类的缓存 DB。亦或是仅作日志收集分析。
    * MongoDB 有一个最大的缺点，就是它占用的空间很大，因为它属于典型空间换时间原则的类型。那么它的磁盘空间比普通数据库会浪费一些。
    * 另外一个就是在一定的时间后，所占空间会莫明其妙地增大，所以要定期把数据库做修复，定期重新做索引，这样会提升 MongoDB 的稳定性和效率，在最新的版本里，它已经在实现在线压缩，可以在后台执行 repair database 的一些操作，有助于解决这一问题。  
  
  
### MongoDB 缺点（主要是无事务机制）
* MongoDB 不支持事务操作（最主要的缺点）
* MongoDB 占用空间过大
* MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和 IT 运营都是个值得注意的地方  
  
  
### 其他例子
#### Redis
* 是一个纯粹的内存数据库（内存满了会发生删除数据或拒绝写入）。
* 持久化方式：Redis 所有数据都是放在内存中的，持久化是使用 RDB 方式或者 aof 方式。  
  
#### DynamoDB
* Key-Value 和 Document 的数据库。
* 比 MongoDB 安全性更高。
* 比 MongoDB 更方便（AWS 完全托管的，将用户从底层基础结构中解放出来，并且仅通过远程端点与数据库进行交互，用户使用 DynamoDB 时无需担心操作问题或关注其他硬件规定）。
* 费用比 MongoDB 昂贵。
* 支持的语言和工具没有 MongoDB 多、生态比 MongoDB 小。  
  
#### 列数据库
在列数据库中，数据围绕列而非行来组织。这样，可以对某些应用的负载更加优化，特别是数据仓库和分析类应用，因为它们在计算时需要聚集大量的相似数据。列数据库（或说面向列的数据库）特别适合那些对大数据集进行查询的在线分析处理（OLAP）应用。  
为了优化磁盘空间和 IO 消耗的时间，在列数据库里，数据存储的工作方式有些许不同。例如，列数据库允许写一条记录时，只写很多列中的一列，并且只有这列会占用实际空间。这和 RDBMS 非常不同，在 RDBMS 里，空值也不是零开销的。你可以把 RDBMS 想象成一个工作表，每行的同一列都占用同样的空间，为了维持表格数据结构的形状，即使没有东西也要维护一个空值在那。这个模型对列数据库根本就不适用，因为没有“空”值存在。列数据可以想象成是标签：值可以是任意长的，并且列的名字和宽度都不做预设。  
列数据库经常要求数据的类型是一致的，这样可以更好地进行数据压缩。  
列数据库最早大约出现在 20 世纪 70 年代早期。Sybase IQ 就是最早的列数据库之一，很多年来，都只有商业的列数据库。  
不过，近几年的项目（主要是开源项目）才是这里讨论的 NoSQL 的一部分，这些数据库演进自基本的键—值存储，但拥有更为丰富的数据模型。可以把这些列数据库看做是多维的键值存储或哈希表，它们不仅支持简单直接的键值对，还允许使用“列族”这样的数据模型来帮助组织各列，提供更丰富的模型。这些列数据库包括 Google 的 BigTable、HBase、Hypertable 和 Cassandra。  
Google 的 Bigtable 是现代列数据库的鼻祖。它是一个内部自用的系统，但是 Google 发表了几篇论文来介绍它的设计，后面所有讨论的列数据库的实现都紧随 Bigtable 的设计。就 Cassandra 而言，它也从 Bigtable 继承了一些关键理念。  

Excerpt From: Eben Hewitt. “Cassandra权威指南”.   
  

### 其他
数据量和性能的比较：当物理内存够用的时候，Redis > MongoDB > MySQL 。  
当物理内存不够用的时候，Redis 和 MongoDB 都会使用虚拟内存。  
MySQL 支持 join，MongoDB 没有 join（因为 MongoDB 这类数据库就是设计成单个数据记录是聚合的/Aggregation。MongoDB 中有一个 lookup 操作，可以做 join 查询，但是理想情况下，这个 lookup 操作应该不会经常使用，如果开发者需要经常使用它，那么开发者就使用了错误的数据库存储了，如果有相关联的数据，应该使用关系型数据库）。  
  
参考链接：https://www.jianshu.com/p/ad8992223812  
