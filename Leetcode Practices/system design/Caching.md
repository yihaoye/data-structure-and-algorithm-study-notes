# 缓存
这里的缓存指的是多个应用服务之间的共享缓存，通常使用 Redis，每个应用服务自己本地也可以使用自己的内存（数据结构如数组、哈希表）作为本地缓存。  
使用缓存数据库之前，首先要明白缓存数据库多数情况下解决的还是性能问题不是功能问题（除非业务本身不需要相关数据持久化只需短时间数据存储且对延时非常敏感，又或者比如需要一些 [Redis 的专业解决方案](../../Computer%20System%20Layer/数据库/Redis/README.md#Redis-使用案例)），只要持久化数据库性能、功能、可用性和成本都还能接受（很多人低估了现代关系数据库的能力，实际上大量系统没上缓存也运行得很好），引入缓存数据库通常是负收益的，会极大增加系统的复杂度、数据不一致以及运维和资本支出成本（内存很贵）。过早优化是万恶之源。  

相关：
* [缓存那些事](https://tech.meituan.com/2017/03/17/cache-about.html)
* [Redis 基本功](../../Computer%20System%20Layer/数据库/Redis/README.md)

缓存在几乎每个计算层级中都被使用：硬件、操作系统、Web 浏览器、Web 应用程序等等（可以存在于体系结构的所有层级中），但通常在最靠近前端的层级中使用。它类似于短期记忆且速度快。注意多级缓存系统可能会带来很多系统复杂性与变数，要视业务场景（数据一致性）判断使用，其中云计算时代使得本地缓存可能实际上没有节省内存资源成本（反而可能增加），从性能上来看更多地是优化了网络 IO 部分。  
![](./cache-systems.jpeg)  

* 本地缓存（应用服务器缓存）- 如果数据不在缓存中，请求节点将从磁盘查询数据（比访问网络存储快）。然而，如果负载均衡（LB）随机分发请求到不同的节点，同样的请求可能会发送到不同的节点，从而增加了缓存未命中。两种克服选择是全局缓存（global caches）和分布式缓存（distributed caches）。
* 内容分发网络（CDN） - CDN 是一种在为大量静态媒体提供服务的站点中发挥作用的缓存。如果内容在本地不可用，CDN 将向后端服务器查询文件，将其缓存到本地并提供给用户。上述操作可以由 Nginx 完成。
* 缓存同步与缓存失效（Cache Invalidation）- 缓存需要一些维护来保持与真实数据源（例如数据库）的一致性，有以下 3 种方案，不过缓存同步无法实现与数据库强一致性的同时高可用因为那是不可能的完美分布式事务，缓存只能当作性能提升工具允许低概率的数据不一致、不能当作事实来源（Source of Truth）。*不过如果数据场景是 “只写一次，永不更新” 的话，则不用太担心缓存双写一致性问题，如果缓存写入失败，只需要在下一次请求触发 Lazy Loading（懒加载/读取时填充）即可（但是要小心缓存三大故障）。*[Ref](https://blog.csdn.net/qq_34827674/article/details/125869674) ![](./Top-caching-strategies.png)
  * 旁路缓存（Cache Aside）- 最常用，应用程序直接与缓存、数据库交互，优点是数据库数据一致性强、缺点是性能相比其他方案差一些且存在数据不一致的可能性（比如请求 A 读取未命中，此时请求 B 在中间迅速完成了一次写入步骤将导致请求 A 用旧数据覆盖了缓存等等这类极端情况），可以使用延迟双删（Delay Double Delete：[Ref 1](https://juejin.cn/post/7447033901657096202)、[Ref 2](https://zhuanlan.zhihu.com/p/6262725224)）或分布式锁这类方案来缓解（但仍不能完全避免一致性问题或引发其他如性能、低可用、缓存击穿问题等等）。旁路缓存大致策略如下：
    * 写入 - 先更新数据库数据，再删除缓存数据
    * 读取 - 如果读取命中缓存，则返回缓存数据；如果读取未命中缓存，则从数据库读取数据，更新缓存，然后返回数据
  * 读取/写入-通过缓存（Read/Write Through）- 应用程序只与缓存交互，数据库更新由缓存代理完成，优点是性能较好、缺点是数据库数据一致性较弱
    * 读取 - 若命中缓存则直接返回数据，否则缓存组件应负责从数据库读取数据，更新缓存，然后返回数据
    * 写入 - 应用更新缓存数据，缓存组件负责将更新写入数据库
  * 写回缓存（Write-Back）- 数据仅写入缓存，将缓存数据设置为待同步标记，然后立即向客户端确认完成，此时不会立刻更新数据库，只在指定的时间间隔或特定条件下进行数据库的异步同步（从缓存中获取待同步标记的数据，批处理写入更新数据库较为高效）。优点是性能最好尤其是大量写入场景、缺点是数据库数据一致性最弱（可能长时间数据不同步）
* 缓存淘汰策略（Cache eviction policies）及其[代码实现](https://www.sakuratears.top/blog/%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95%EF%BC%88LFU%E3%80%81LRU%E3%80%81FIFO%E3%80%81ARC%E3%80%81MRU%EF%BC%89.html)
  * 先进先出（FIFO）
  * 后进先出（LIFO）
  * 最近最少使用（LRU）
  * 最近最常使用（MRU）（[使用场景](https://stackoverflow.com/questions/5088128/why-does-cache-use-most-recently-used-mru-algorithm-as-evict-policy)）
  * 最不常使用（LFU - Least Frequently Used）
  * 自适应缓存替换（ARC）（结合了 LRU 与 LFU 的特点）
  * 随机替换（RR - Random Replacement）

![](./cache-related.jpeg)  

其他：[Ring Buffer / Circular Buffer](https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80)  

分层缓存（Tiered Cache）：将缓存分成多个层级，每个层级具有不同的容量和速度。通常将最常访问的数据存储在速度较快的高层级缓存中，较少访问的数据存储在速度较慢的低层级缓存中。  

## [缓存三大故障：缓存雪崩、击穿与穿透](../../Computer%20System%20Layer/数据库/Redis/README.md#缓存三大故障)

## 垃圾回收
缓存的淘汰策略会与内存释放息息相关，因此要注意相关性能的影响，比如用 C 语言实现的 Redis，在进行淘汰策略时是使用主动的内存管理，因此性能最优，如果是依赖垃圾回收机制的语言如 Java、Go 等实现缓存的淘汰策略时，要注意垃圾回收带来的性能影响，在读写更新十分频繁的情况下可能会放大负面影响。  

## 过时策略
通常是随机抽样检查和惰性检查的组合（By ChatGPT）：
* 随机抽样检查 - Redis 会周期性地对部分过期键进行检查和清理。这种策略可以保证即使某些键因为惰性检查而未被删除，仍然能够在随机抽样检查中被及时清理，提高过期键的清理效率。Redis 通过在每次执行完数据库命令后，以一定的概率来触发随机抽样检查。
* 惰性检查 - 当访问键时，Redis 会在需要时检查键是否过期，并根据过期状态进行删除。这种策略能够保证在访问键时能够及时地发现过期键，并删除它们。惰性检查是 Redis 的默认过期策略，它在访问时检查键的过期状态，并在需要时删除过期的键。

## 块缓存（Block Cache）
块缓存通常可以用来缓存各种类型的数据，包括视频、文件等大型数据块。块缓存适用于任何需要频繁访问的数据块，无论其类型是文本、图片、视频、音频还是其他格式。  
在存储视频、文件等大型数据时，块缓存可以有效地减少对底层存储介质（如磁盘或网络存储）的访问次数，从而提高数据的读取性能。通过将这些数据块加载到内存中的缓存中，应用程序可以更快地获取数据，减少了读取时间，并且在用户体验方面能够得到显著的改善。  
然而，需要注意的是，缓存大型数据块可能会占用较多的内存空间，因此在设计缓存策略时需要平衡内存的使用和缓存命中率。对于特别大的数据块，也可以考虑使用分布式文件系统或对象存储等技术来管理和存储这些数据，以确保系统的可扩展性和性能。  
支持块缓存的软件系统有 HBase、RocksDB 等等。  

By ChatGPT  
