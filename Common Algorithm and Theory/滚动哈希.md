# 滚动哈希

https://www.jianshu.com/p/24895aca0459  
https://www.youtube.com/watch?v=GcgpR3KHgBs  
https://blog.csdn.net/m0_37846371/article/details/72854890  
  
又称 Rabin-Karp 算法。是一种基于散列的字符串查找算法。通常情况下，基于散列的字符串查找步骤是：  
1. 首先计算模式字符串的散列函数；
2. 然后利用相同的散列函数计算文本中所有可能的 M 个字符的子字符串的散列函数值并寻找匹配

但是这种方法比暴力查找还慢，因为计算散列值会涉及字符串中的每个字符。Rabin 和 Karp 对上述方法进行了改进，发明了一种能够在常数时间内算出 M 个字符的子字符串散列值的方法。  
  
## 基本思想
以文本 “3141592653589793”，模式串 “26535” 为例。  
比较思路如下：  
寻找一个大素数（作为散列表的大小），通过 “除留余数法” 计算模式串的散列值。然后依次计算文本中的相同长度子串的散列值，进行比较。  
![](./Rolling%20Hash.png)  

递推文本串的散列值：  
以 T<sub>i</sub> 表示文本字符 `T[i]`，X<sub>i</sub> 表示文本串 `T[i...i+M-1]` 的整数值，其中 M 为模式串长度，则：  
![](Rolling%20Hash%201.png)  
  
递推可以得到：  
![](./Rolling%20Hash%202.png)  
  
可以在初始时求得字符串 `T[0...M-1]` 的 hash 值，即 hash(txt, 0, M-1) = X<sub>0</sub> % P（其中 P 为大素数）；  
然后通过上述公式递推就可以得到字符串 `T[i+1...i+M]` 的 hash 值，即 X<sub>i+1</sub> % P。  
  
## 代码实现
```java
public int match(String txt, String ptn) {
    int N = txt.length();
    int M = ptn.length();
    if (M > N) return -1;
 
    long txtHash = hash(txt, 0, M - 1); // 计算文本串 txt[0...M-1] 的 hash 值
    long ptnHash = hash(ptn, 0, M - 1); // 计算模式串的 hash 值
    // 首先做一次匹配
    if (ptnHash == txtHash) return 0;
 
    // 计算 R^(M-1)%P, 后续公式递推求值用到
    long RM = 1;
    for (int i = 1; i <= M - 1; i++) {
        RM = (RM * R) % P;
    }
 
    // 从文本的第 1 个字符开始查找
    for (int i = 1; i <= N - M; i++) {
        // 根据递推公式，计算文本串 hash 值
        txtHash = (txtHash + P - RM * txt.charAt(i - 1) % P) % P;
        txtHash = (txtHash * R + txt.charAt(i + M - 1)) % P;
 
        if (txtHash == ptnHash) return i;
    }
    return -1;
}

public long hash(String str, int startIndex, int endIndex) {
    long res = 0L;
    // customize ...
    return res;
}
```  
  
## 性能分析
Rabin-Karp 算法，由于通过计算模式串和文本子串的散列值来做相等性比较，所以有一定概率出现冲突，即散列值相同但是字符串不匹配。  
出现冲突的概率与大素数的选择有关，概率约为 1/Q（Q 为大素数的值），实际应用中，该算法是可靠的，只有极小的概率会出现冲突。  
  
时间复杂度 O(N+M)  
  
## 例题
* [LC Q187](./../Leetcode%20Practices/algorithms/medium/187%20Repeated%20DNA%20Sequences.java)  
