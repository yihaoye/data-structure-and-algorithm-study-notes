## 倍增
https://blog.csdn.net/jarjingx/article/details/8180560  

倍增法（binary lifting），顾名思义就是翻倍。它能够使线性的处理转化为对数级的处理，大大地优化时间复杂度。  
这个方法在很多算法中均有应用，其中最常用的是 RMQ 问题和求 LCA（最近公共祖先） 。  
  
可以这么理解：它是一种类似于二分的方法，不过这里不是二分，而是倍增，以 2 倍、4 倍、等等倍数增长。  
具体理解建议参考以下例子及 LCA。  
  
### 例子
例题  
如何用尽可能少的砝码称量出 [0, 31] 之间的所有重量？（只能在天平的一端放砝码）  
  
解题思路  
答案是使用 1 2 4 8 16 这五个砝码，可以称量出 [0, 31] 之间的所有重量。同样，如果要称量 [0, 127] 之间的所有重量，可以使用 1 2 4 8 16 32 64 这七个砝码。每次都选择 2 的整次幂作砝码的重量，就可以使用极少的砝码个数量出任意所需要的重量。  
为什么说是极少呢？因为如果要量出 [0, 1023] 之间的所有重量，只需要 9 个砝码，需要量出 [0, 1048575] 之间的所有重量，只需要 19 个。如果我们的目标重量翻倍，砝码个数只需要增加 1。这叫“对数级”的增长速度，因为砝码的所需个数与目标重量的范围的对数成正比。  
  
### 应用
#### 树上倍增求 LCA
LCA (最近公共祖先)。  
预处理操作 O(N*logN)，查询 O(logN)。  

主要思路即 —— 两个节点平层同时往上跳，直到相遇，相遇的点就是它们的 LCA。但是很明显，如果这棵树的深度较大，那么一层层跳要跳很久（朴素算法，复杂度 O(n*m)）。所以可以采用倍增优化 —— 大步大步地跳。  
  
实现步骤：  
1. 存储一棵树（邻接表法）
2. 获取树各节点的上的深度（dfs 或 bfs）
3. 获取 2 次幂祖先的节点，用 parents[n+1][l+1] 数组存储，倍增法关键
4. 用倍增法查询 LCA  
  
关键要记录下每个节点的父节点和各个祖先节点，parents[u][] 数组存储的是 u 节点的祖先节点。(另外用 from[] 数组记录各节点的父节点，其中没有父节点的就是 root；以及用 depth[] 数组记录各节点的深度)  
如 parents[u][0]，是 u 节点的 2⁰ 祖先节点，即 1 祖先，也即父节点。在输入过程中可以直接得到。  
parents[u][1]，是 u 节点的 2¹ 祖先节点，即 2 祖先，也即父亲的父亲。  
parents[u][2]，是 u 节点的 2² 祖先节点，即 4 祖先，也即父亲的父亲的父亲的父亲。  
以此类推，这样在更新的时候就可以得到一个递推式：`parents[u][i] = parents[parents[u][i - 1]][i - 1]`。就可以预处理出每个节点的各个祖先。  
*parents 数组的意义，它存的是节点 u 的 2 次幂祖先，从父亲节点开始。为什么要存 2 次幂？这就是倍增法的思想了，进行范围缩小不是一步一步的，那样太暴力/太慢了，所以需要某个跨度，让程序能够先跳大步，接近的时候再小步小步跳，这样可以大大节省时间。先大步，后小步，可是怎么知道什么时候该大步，什么时候该小步呢？难道不会不小心跳过头吗？其实不会的，在代码实现上，这样的跨度有条件约束。*  
  
然后：  
1. 首先确定深度更大（或相同）的节点 u，`if (depth[u] < depth[v]) swap(u, v);`，使满足 u 深度更大，便于后面操作
2. 然后获取最大跨度 l，所有的跨越都是从 l 开始的（l 等于 logN：`int l = (int)Math.ceil(Math.log(n) / Math.log(2));`，其中 n 为树的节点总数）
3. 再然后把 u 上升到和 v 一样的深度
4. 最后，两个节点同时迭代往上跳（跨越从 l 开始），直到找到 LCA  
  
步骤 3：u 上升到和 v 一样的深度（让深度更深的一个先往上跳，好让两个之后再一起跳）  
```java
for (int i = l; i >= 0; i--) {
    if ((depth[u] - (int)Math.pow(2, i)) >= depth[v]) // 是 >=，因为如果 <，代表跳过头了，跳到了上面
        u = parents[u][i];
}
```  
  
步骤 4：在向上跳时，已让 u 和 v 处于同一层。当然，在刚刚得到两点平层的时候可以特判一下：是否两点已经汇合了，是则可以返回了。  
```java
// 找出最靠近根节点的不相同的节点，即 LCA 的子节点，然后再返回这个节点的父节点即可
for (int i = l; i >= 0; i--) {
    if (parents[u][i] != parents[v][i]) {
        u = parents[u][i];
        v = parents[v][i];
    }
}

return parents[u][0];
```  
  
参考：  
https://blog.csdn.net/wjh2622075127/article/details/81060586  
https://blog.csdn.net/qq_43326267/article/details/90316348  
https://cp-algorithms.com/graph/lca_binary_lifting.html  
https://www.geeksforgeeks.org/lca-in-a-tree-using-binary-lifting-technique/  
  
  
#### RMQ 问题
RMQ 是 Range Maximum/Minimum Query 的缩写，表示区间最大（最小）值。使用倍增思想解决 RMQ 问题的方法是 ST 表 。  
  