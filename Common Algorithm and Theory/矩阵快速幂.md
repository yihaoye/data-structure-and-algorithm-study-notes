# 矩阵快速幂

矩阵快速幂与快速幂的思想是一致的：求矩阵的幂 A<sup>n</sup> 的时候，先不求 A<sup>n</sup>，而是先求 A<sup>n/2</sup>，然后先不求 A<sup>n/2</sup> ，而是先求 A<sup>n/4</sup> ...   
以上思路同样可以用二进制分解加位掩码来实现，只是当某个位掩码为 1 表示该位需要的时候，做的是快速幂做的是乘法，矩阵快速幂做的是矩阵乘法。  
https://hezhaojiang.github.io/post/2020/41da3a83/  

简示
```java
public class MatrixExponentiation {
    // 此处是关键，在于通过不断地将矩阵自身与其乘积来实现快速幂次计算，这一过程通过“平方-乘”算法实现
    public static int[][] matrixMultiply(int[][] A, int[][] B) {
        int n = A.length; // 假设 A 和 B 都是 n x n 的矩阵
        int[][] C = new int[n][n]; // 结果矩阵 C 也是 n x n 的矩阵
        for (int r = 0; r < n; r++) { // 遍历矩阵 C 的行
            for (int c = 0; c < n; c++) { // 遍历矩阵 C 的列
                for (int k = 0; k < n; k++) { // 计算 C[r][c] 的值
                    C[r][c] += A[r][k] * B[k][c]; // 乘积和累加
                }
            }
        }
        return C; // 返回结果矩阵
    }

    public static int[][] matrixPower(int[][] A, int n) {
        int len = A.length;
        int[][] result = new int[len][len];
        // Initialize result as the identity matrix
        for (int i = 0; i < len; i++) {
            result[i][i] = 1;
        }
        while (n > 0) {
            if ((n & 1) == 1) {
                result = matrixMultiply(result, A);
            }
            A = matrixMultiply(A, A);
            n >>= 1;
        }
        return result;
    }

    public static void main(String[] args) { // 斐波那契数列 O(logN * M^3)，3 是因为 matrixMultiply 进行了 3 层 for loop
        int[][] F = { // M*M
            {1, 1},
            {1, 0}
        };
        int N = 13; // 计算第 13 个斐波那契数
        int[][] result = matrixPower(F, N - 1); // F^(N-1)

        // 第 N 个斐波那契数是 result[0][0] + result[0][1]
        int fibonacciN = result[0][0] + result[0][1];
        System.out.println("The " + N + "th Fibonacci number is: " + fibonacciN);
    }
}
```
理解 "一次 matrixMultiply 进行了之前 logN 次的计算" - 平方-乘算法的应用  
1. **基本思路**：
   - 平方-乘算法（或者说矩阵快速幂算法）利用了指数 N 的二进制展开。
   - 将 N 转换为二进制形式，例如 N = 13 的二进制表示为 1101。
2. **算法步骤**：
   - 从最低位（最右边）开始处理二进制位：
     - 如果当前位是 1，则进行一次矩阵乘法操作。
     - 每次移动到下一位时，先进行平方操作。
   - 这样一来，每次迭代时，矩阵乘法的次数是对数级别的，即 logN 次。
3. **时间复杂度分析**：
   - 在每一步操作中，矩阵乘法的时间复杂度为 O(m^3)。
   - 总共进行 logN 次乘法操作，因此总的时间复杂度为 O(logN * m^3)。

### 举例说明

假设我们要计算 A^13，按照矩阵快速幂的步骤：

- A^1 = A
- A^2 = A \cdot A
- A^4 = A^2 \cdot A^2
- A^8 = A^4 \cdot A^4
- A^13 = A^8 \cdot A^4 \cdot A

这里，只进行了 log13 = 4 次乘法操作，即 A^8 \cdot A^4 \cdot A，而不是 13-1 = 12 次乘法操作。
