# 矩阵快速幂

矩阵快速幂与快速幂的思想是一致的：求矩阵的幂 A<sup>n</sup> 的时候，先不求 A<sup>n</sup>，而是先求 A<sup>n/2</sup>，然后先不求 A<sup>n/2</sup> ，而是先求 A<sup>n/4</sup> ...   
以上思路同样可以用二进制分解加位掩码来实现，只是当某个位掩码为 1 表示该位需要的时候，做的是快速幂做的是乘法，矩阵快速幂做的是矩阵乘法。  
https://hezhaojiang.github.io/post/2020/41da3a83/  

```java
public class FibonacciMatrixExponentiation { // GPT, O(logN)
    static final int M = 2;

    static class Matrix {
        long[][] a;

        Matrix() {
            a = new long[M][M];
        }

        void init() {
            a[0][0] = 1;
            a[1][1] = 1;
            a[0][1] = 0;
            a[1][0] = 0;
        }

        Matrix multiply(Matrix B) {
            Matrix ans = new Matrix();
            for (int i = 0; i < M; i++) {
                for (int j = 0; j < M; j++) {
                    ans.a[i][j] = 0;
                    for (int k = 0; k < M; k++) {
                        ans.a[i][j] += this.a[i][k] * B.a[k][j];
                    }
                }
            }
            return ans;
        }

        Matrix power(int n) {
            Matrix ans = new Matrix();
            ans.init();
            Matrix A = this; // Copy the matrix for self-multiplication
            while (n > 0) {
                if ((n & 1) == 1) {
                    ans = ans.multiply(A);
                }
                A = A.multiply(A);
                n >>= 1;
            }
            return ans;
        }
    }

    public static long fibonacci(int n) {
        if (n <= 1) return n;

        Matrix F = new Matrix();
        F.a[0][0] = 1;
        F.a[0][1] = 1;
        F.a[1][0] = 1;
        F.a[1][1] = 0;

        Matrix result = F.power(n - 1);

        return result.a[0][0]; // F(n) is stored in result.a[0][0]
    }

    public static void main(String[] args) {
        int n = 10; // Change this to the desired Fibonacci index
        System.out.println("Fibonacci number " + n + " is " + fibonacci(n));
    }
}
```
