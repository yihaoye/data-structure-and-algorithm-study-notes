## 分治法
分治法是建基于多项分支递归的一种很重要的算法范型。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。  
这个技巧是很多高效算法的基础，如排序算法（归并排序、快速排序）、傅立叶变换（快速傅立叶变换）、MapReduce、分桶法等等。  
另一方面，理解及设计分治法算法的能力需要一定时间去掌握。正如以归纳法去证明一个理论，为了使递归能够推行，很多时候需要用一个较为概括或复杂的问题去取代原有问题。而且并没有一个系统性的方法去适当地概括问题。  
  
分治法这个名称有时亦会用于将问题简化为只有一个细问题的算法，例如用于在已排序的列中查找其中一项的折半搜索算法（或是在数值分析中类似的勘根算法）。这些算法比一般的分治算法更能有效地运行。其中，假如算法使用尾部递归的话，便能转换成简单的循环。但在这广义之下，所有使用递归或循环的算法均被视作“分治算法”。因此，有些作者考虑“分治法”这个名称应只用于每个有最少两个子问题的算法。而只有一个子问题的曾被建议使用减治法这个名称。  
分治算法通常以数学归纳法来验证。而它的计算成本则多数以解递归关系式来判定。  
  
### 时间复杂度
时间复杂度不固定，比如若是指数分解（或者说开方分解）则为 `O(a*loga N)` 以 a 为底 N 的对数 - a 为指数分解的指数（[案例 Pow(x, n)](./../Leetcode%20Practices/algorithms/medium/50%20Pow(x,%20n).java)）（但是要注意 a 不是越大越好，因为最佳为 `O(e*logeN)`，所以通常开方、快速幂 O(logN) 就足够好了），若是线性分解则为 O(N)，其他分解情况下其时间复杂度还有可能是其他大 O 比如归并算法 O(N*logN)。  
  
### Leetcode 案例
[Pow(x, n)](./../Leetcode%20Practices/algorithms/medium/50%20Pow(x,%20n).java)  
  
### 分治法 vs 二分算法
二分：通过 O(1) 的操作，将规模为 n 的问题变成了 n/2 的问题。  
即：T(n) = T(n/2) + O(1)  
分治：通过 O(1) 的操作，将规模为 n 的问题变成了 2 个 n/2 的问题（线性分解的情况）。  
即：T(n) = 2 T(n/2) + O(1)  
区别：分治（线性分解）的问题规模并没有变  
