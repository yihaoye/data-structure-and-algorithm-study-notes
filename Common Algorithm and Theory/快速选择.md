# 快速选择
Floyd–Rivest algorithm 与其类似  

期望为线性时间的选择算法  
  
问题：找出数组中第 i 小的元素。  
  
思想  
采用“排序+索引”的方法，其时间复杂度依赖排序算法，为 O(N*logN)，并非最有效的算法。  
采用类似快速排序的算法思想来进行选择，可将时间复杂度在问题平均分布的情况下降为线性的 O(N)。  
不同于快排的是，在定位到中位并进一步递归查找时，不需要左右两边都递归调用，仅一边递归调用即可。  
  
基于快速排序的选择方法，时间复杂度：O(N)，证明过程参考《算法导论》9.2：期望为线性的选择算法。空间复杂度：O(1)。  
快速选择的总体思路与快速排序一致，选择一个元素作为基准来对元素进行分区，将小于和大于基准的元素分在基准左边和右边的两个区域。不同的是，快速选择并不递归访问双边，而是只递归进入一边的元素中继续寻找。这降低了平均时间复杂度，从 O(N*logN) 至 O(N)，不过最坏情况仍然是 O(N^2)。  

常见的例子是求数组的第 k 小的数，运用快速选择算法的基本流程如下：
1. 首先选定一个轴心值 p。
2. 将数组中小于 p 的值移到数组左端，其他移动到数组右端。
3. 计算轴心左端的数 (包括轴心自己) 有多少，记为 count。
4. 如果 count 正好为 k，则返回此时轴心值，此值即为第 k 小的数。
5. 如果左端的数 count 大于 k，说明在左端，所以只递归左边即可。
6. 如果不在左端，只递归在右边寻找。
  
## 模版/例题
[Leetcode 215 Kth Largest Element in an Array](./../Leetcode%20Practices/algorithms/medium/215%20Kth%20Largest%20Element%20in%20an%20Array.java)  
