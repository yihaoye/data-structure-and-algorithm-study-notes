# 匈牙利算法
匈牙利算法是一种在[多项式时间](https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E9%A0%85%E5%BC%8F%E6%99%82%E9%96%93)内求解[任务分配问题](https://zh.wikipedia.org/zh-hans/%E4%BB%BB%E5%8A%A1%E5%88%86%E9%85%8D%E9%97%AE%E9%A2%98)的[组合优化](https://zh.wikipedia.org/zh-hans/%E7%BB%84%E5%90%88%E4%BC%98%E5%8C%96)算法，并推动了后来的原始对偶方法。该算法 1955 年提出。此算法之所以被称作匈牙利算法，是因为算法很大一部分是基于以前匈牙利数学家 Dénes Kőnig 和 Jenő Egerváry 的工作之上创建起来的。  

1957 年回顾了该算法，并发现它的时间复杂度为（强）多项式时间。此后该算法被称为 Kuhn–Munkres 算法或 Munkres 分配算法。原始算法的时间复杂度为 O(n^4)，但后来发现可以修改算法达到 O(n^3) 运行时间，该方法后来推广到了一般运输问题。  

## 增广路
以下转载自：https://zhuanlan.zhihu.com/p/208596378  

匈牙利算法原理基础：[增广路](./图匹配.md#增广路定理-berges-lemma)  
利用增广路找最大匹配的算法，就叫做匈牙利算法。

总结一下匈牙利算法：  
每个点从另一个集合里挑对象，没冲突的话就先安排上，要是冲突了就用增广路径重新匹配。重复上述思路，直到所有的点都找到对象，或者找不到对象也找不到增广路。  

### 深度优先和广度优先
上述是深度优先匈牙利算法。就是冲突了立刻用增广路来解决。  

另外一种是广度优先匈牙利算法。思路是，冲突了就换一个心仪对象，看另一个心仪对象是不是也配对了，要是都配对了，再用增广路来解决。  

广度优先的流程是这样的：  
1. A 和 a 连上。
2. B 也想连 a，但是 a 被连了，就找下一个心仪对象 b。
3. b 没有被连上，B 和 b 就连在一起。
4. 轮到 C 的时候，C 找心仪对象 c。
5. c 也没被连上，所以 C 和 c 连一起。
