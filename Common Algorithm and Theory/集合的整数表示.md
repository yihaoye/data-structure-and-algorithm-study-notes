集合的整数表示通常用位运算来实现，称为 "位图" 或 "位向量"。在位图中，每个整数位代表一个元素是否存在于集合中。如果第 i 位为 1，表示集合中存在元素 i；如果为 0，表示集合中不存在元素 i。  

Java 里提供了 BitSet 可直接使用。BitSet 中的每个位（0 或 1）都占用一个比特（bit）的存储空间。这是位向量（Bit Vector）的基本特性，每个元素都用一个比特表示。  
在 Java 中，`BitSet` 类可以表示非常大的位集合，最大长度由整数值的位数决定，即 32 位或 64 位，具体取决于 Java 运行时环境的架构。通常情况下：
- 在 32 位架构的 Java 虚拟机上，`BitSet` 的最大大小为 2^31 - 1，即 2,147,483,647 位。
- 在 64 位架构的 Java 虚拟机上，`BitSet` 的最大大小为 2^63 - 1，即 9,223,372,036,854,775,807 位。

这个大小远远超过了绝大多数实际应用中所需的位数，因此 `BitSet` 通常可以满足大多数位操作的需求。如果需要处理更大的位集合，可能需要考虑使用其他更专门的位操作库或自定义数据结构。  

使用位图可以高效地执行集合操作，例如并集、交集、差集等。由于每个操作只涉及位运算，这些操作通常比使用传统的数据结构如数组或链表更快。但需要注意的是，位图通常适用于元素范围较小且集合操作频繁的情况，因为位图的空间复杂度与范围成线性关系。  

（1）空集 ------------------------------------------------------------> 0
（2）只含有第 i 个元素的集合 { i } ----------------------------------> 1 << i
（3）含有全部 n 个元素的集合 {0， 1， ...， n-1} --------------> (1 << n) - 1
（4）判断第 i 个元素是否属于集合 S ------------------------------> if (S >> i & 1)
（5）向集合中加入第 i 个元素 S U { i } ----------------------------> S | 1 << i
（6）从集合中删去第 i 个元素 S \ { i } -----------------------------> S & ~ (1 << i)
（7）集合 S 和 T 的并集 S U T -------------------------------------> S | T
（8）集合 S 和 T的交集 S ∩ T --------------------------------------> S & T

参考：https://www.cnblogs.com/jaszzz/p/12849648.html  
