# 记忆化搜索

开个数组 mem, 记录下来每个 dfs() 的返回值。刚开始把 mem 中每个值都设成 -1（代表没访问过）。每次刚刚进入一个 dfs 前（此时 dfs 是递归调用的），都判断 `mem[i]` 是否为 -1, 如果是就正常执行并把答案记录到 mem 中，否则直接返回 mem 中的值。  

**记忆化搜索约等于动态规划**，（应该）任何一个 dp 方程都能转为记忆化搜索  
大部分记忆化搜索的状态/转移方程与 dp 都一样，时间复杂度/空间复杂度与 不加优化的 dp 完全相同  
一般说来，动态规划总要遍历所有的状态，而搜索可以排除一些无效状态。更重要的是搜索还可以剪枝，可能剪去大量不必要的状态，因此在空间开销上往往比动态规划要低很多。记忆化算法在求解的时候还是按着自顶向下的顺序，但是每求解一个状态，就将它的解保存下来，以后再次遇到这个状态的时候，就不必重新求解了。这种方法综合了搜索和动态规划两方面的优点。  

## 如何写记忆化搜索
* 方法（举例 - 最长上升子序列）
  1. 把这道题的 dp 状态和方程写出来
  2. 根据它们写出 dfs 函数
  3. 添加记忆化数组


## 记忆化搜索的优缺点
优点：  
* 记忆化搜索可以避免搜到无用状态，特别是在有状态压缩时
* 不需要注意转移顺序（这里的 “转移顺序” 指正常 dp 中 for 循环的嵌套顺序以及循环变量是递增还是递减）
* 边界情况非常好处理，且能有效防止数组访问越界
* 有些 dp（如区间 dp) 用记忆化搜索写很简单但正常 dp 很难
* 记忆化搜索天生携带搜索天赋，可以使用技能 “剪枝”

缺点：  
* 致命伤：不能滚动数组
* 有些优化比较难加
* 由于递归，有时效率较低但不至于 TLE（状压 dp 除外）

## 模板
```
int g[MAXN];

int f(状态参数) {
  if (g[规模] != 无效数值) return g[规模];
  if (终止条件) return 最小子问题解;
  g[规模] = f(缩小规模);
  return g[规模];
}

int main() {
  // ...
  memset(g, 无效数值, sizeof(g));
  // ...
}
```
