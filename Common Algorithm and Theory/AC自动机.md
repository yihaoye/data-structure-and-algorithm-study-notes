# AC 自动机
Aho–Corasick algorithm 是一种字符串搜索算法，用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。然而由于需要找到所有匹配数，如果每个子串互相匹配（如字典为 a，aa，aaa，aaaa，输入的字符串为 aaaa），算法的时间复杂度会近似于匹配的二次函数。  
该算法主要依靠构造一个有限状态机（类似于在一个 trie 树中添加失配指针）来实现。这些额外的失配指针允许在查找字符串失败时进行回退（例如设 Trie 树的单词 cat 匹配失败，但是在 Trie 树中存在另一个单词 cart，失配指针就会指向前缀 ca），转向某前缀的其他分支，免于重复匹配前缀，提高算法效率。  
  
## 概述
> 我们经常用的字符串方法 indexOf，都是判定两个字符串的包含关系，底层使用类似 KMP、BM、Sunday 这样的算法。如果我们要判断一个长字符串是否包含多个短字符串呢？比如在一篇文章找几个敏感词，在 DNA 串中找几个指定的基因对 pattern 进行预处理，如果我们的模式串存在多个，则不适合了，我们就需要用到一种多模式匹配算法。  
> 最著名的多模式匹配算法为 AC 自动机，它是由贝尔实验室的两位研究人员 Alfred V. Aho 和 Margaret J.Corasick 于 1975 年发明的，几乎与 KMP 算法同时问世，至今日仍然在模式匹配领域被广泛应用。  
> AC 自动机的核心算法仍然是寻找模式串内部规律，达到在每次失配时的高效跳转。这一点与单模式匹配 KMP 算法是一致的。不同的是，AC 算法寻找的是模式串之间的相同前缀关系。  
> 在 KMP 算法中，对于模式串 “abcabcacab”，我们知道非前缀子串 abc(abca)cab 是模式串的一个前缀 (abca)bcacab，而非前缀子串 ab(cabca)cab 不是模式串 abcabcacab 的前缀，根据此点，我们构造了 next 数组，实现在匹配失败时的跳转。  
> 而在多模式环境中，AC 自动机是使用前缀树来存放所有模式串的前缀，然后通过失配指针来处理失配的情况。它大概分为三个步骤：构建前缀树（生成 goto 表），添加失配指针（生成 fail 表），模式匹配（构造 output 表）。

```javascript
var ac = new Trie();
createGoto(ac, ["she", "shr", "say", "he", "her"]);
createFail(ac);
console.log(match(ac, "one day she say her has eaten many shrimps"));
```  
![](./ac-automaton.webp)  

### [JS 代码实现](./ac_automaton.js)
### [Java 代码实现](./AcAutomaton.java)

以上参考：https://zhuanlan.zhihu.com/p/80325757  

### 构造优化以及删除实现
比如在每次添加一个匹配模式后自动触发并只改相关的局部节点？  
可能的方案比如使用一个全局哈希表记录需要改动的节点？[可能的参考](https://burningmime.gitlab.io/setmatch/implementation-overview.html#supporting-add-remove-in-an-aho-corasick-trie)  

## 补充
> AC 自动机是以 Trie（字典树）的结构为基础，结合 KMP 的思想建立的。  
> 简单来说，建立一个 AC 自动机有两个步骤：  
> 1. 基础的 Trie 结构：将所有的模式串构成一棵 Trie。
> 2. KMP 的思想：对 Trie 树上所有的结点构造失配指针。
> 
> 然后就可以利用它进行多模式匹配了。
>
> AC 自动机在初始时会将若干个模式串丢到一个 Trie 里，然后在 Trie 上建立 AC 自动机。这个 Trie 就是普通的 Trie，该怎么建怎么建。  
> 
> 因为 KMP 只对一个模式串做匹配，而 AC 自动机要对多个模式串做匹配。所以有可能 fail 指针指向的结点对应着另一个模式串，两者前缀不同。  
> 简单来说，AC 自动机的失配指针指向当前状态的最长后缀状态即可。  
> AC 自动机在做匹配时，同一位上可匹配多个模式串。

### 进阶优化
AC 自动机中，每次匹配，会一直向 fail 边跳来找到所有的匹配，但是这样的效率较低。如何优化呢？首先需要了解 fail 指针的一个性质：一个 AC 自动机中，如果只保留 fail 边，那么这些边的集合一定是一棵树。这是显然的，因为 fail 不会成环，且深度一定比现在低，所以得证。而 AC 自动机的匹配就可以转化为在 fail 树上的链求和问题
* 拓扑排序优化建图 - 每次都要跳 fail。如果可以预先记录，最后一并求和，那么效率就会优化。于是按照 fail 树建图（不用真的建，只需要记录入度）
* 子树求和 - 和拓扑排序的思路接近，预先将子树求和，询问时直接累加和值即可

### AC 自动机上 DP
题目：比如在 AC 自动机上对于所有 fail 指针的子串转移，要取最大值得到答案  
如果采用朴素方法，跳每个节点的 fail，则复杂度会增加，再看看题目的特殊性质，发现所有单词的长度只有 x 位，所以可以想到状态压缩优化  
具体为将前 x 位字母中，可能的子串长度存下来，并压缩到状态中，存在每个子节点中  

以上参考：https://oi-wiki.org/string/ac-automaton/  
  