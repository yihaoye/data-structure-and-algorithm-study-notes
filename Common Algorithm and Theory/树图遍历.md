遍历既可以应用在树上也可以应用在图上，无论是树还是图，遍历都可以大致分为两类：1. 深度优先，2. 广度优先。  
  
树的遍历：  
1. 深度优先：深度优先又可以分为三类：即前序遍历、中序遍历和后序遍历。（以下是树遍历的图解，例子中的树为二叉搜索树 BST，遍历也适合其他的树数据结构）
   ![](树的三种遍历.png)
2. 广度优先：（无论图还是树，一般常用 Queue 来实现广度优先搜索）。
  


图遍历模版：  
使用 BFS 与 DFS 遍历图  
使用 BFS 与 DFS 判断图是否有环  
```java
class Edge { // data structure to store graph edges
	int source, dest;

	public Edge(int source, int dest) {
		this.source = source;
		this.dest = dest;
	}
}

class Graph { // class to represent a graph object
	Map<Integer, List<Integer>> adjMap = new HashMap<>(); // A map represent each node and its adjacency nodes
   boolean undirected = true;
   Map<Integer, Integer> indegree = null; // 用于拓扑排序卡恩算法 - BFS 检测有向图是否有环

	Graph (List<Edge> edges, boolean undirected = true) {
      this.undirected = undirected;
      if (!this.undirected) indegree = new HashMap<>();
		for (Edge edge : edges) { // add edges to the undirected graph
			int source = edge.source;
			int dest = edge.dest;
         adjMap.computeIfAbsent(source, k -> new ArrayList<Integer>() {{ add(dest); }});
         if (this.undirected) {
            adjMap.computeIfAbsent(dest, k -> new ArrayList<Integer>() {{ add(source); }});
         } else {
            indegree.put(source, indegree.getOrDefault(source, 0)); // 保证 0 入度节点也在 indegree 哈希表
            indegree.put(dest, indegree.getOrDefault(dest, 0) + 1); // increment in-degree of destination vertex by 1
         }
		}
	}

   public void dfs(Integer start) { // Time: O(V+E), Space: O(V)
      recurse(start, new HashSet<>());
   }

   private void recurse(Integer cur, Set<Integer> visited) {
      if (visited.add(cur)) {
         System.out.println(cur);
         for (int next : adjMap.getOrDefault(cur, new ArrayList<>())) {
            recurse(next, visited);
         }
      }
   }

   public void bfs(Integer start) { // Time: O(V+E), Space: O(V)
      Set<Integer> visited = new HashSet<Integer>() {{ add(start); }};
      Queue<Integer> queue = new LinkedList<Integer>() {{ add(start); }};
      while (!queue.isEmpty()) {
         int cur = queue.poll();
         System.out.println(cur);
         for (int next : adjMap.getOrDefault(cur, new ArrayList<>())) {
            if (visited.add(next)) queue.add(next);
         }
      }
   }

   public boolean dfsDetectCycle(Integer start) {
      Set<Integer> visited = new HashSet<>();
      if (this.undirected) { // 无向图 Time: O(V), Space: O(V); https://www.baeldung.com/cs/cycles-undirected-graph
         return dfsDetectUndirectedGraphCycle(Integer.MIN, start, visited); // 应该用 null，为了 recurse 代码简洁直观用 MIN 特殊代替
      } else { // 有向图
         // [拓扑排序 DFS 算法](./拓扑排序.md)
      }
   }

   private boolean dfsDetectUndirectedGraphCycle(Integer parent, Integer cur, Set<Integer> visited) {
      visited.add(cur);
      for (int next : adjMap.get(cur)) { // 无向图，所有节点在哈希表均有 dest/to 节点，无需 getOrDefault
         if (visited.contains(next)) {
            if (cur == next || next != parent) return true;
         } else if (dfsDetectUndirectedGraphCycle(cur, next, visited)) {
            return true;
         }
      }
      return false;
   }

   public boolean bfsDetectCycle(Integer start) {
      if (this.undirected) { // 无向图 Time: O(V), Space: O(V)
         Set<Integer> visited = new HashSet<>();
         Queue<int[]> queue = new LinkedList<>() {{ add(new int[]{Integer.MIN, start}); }};
         while (!queue.isEmpty()) {
            int[] parentAndCur = queue.poll();
            int parent = parentAndCur[0], cur = parentAndCur[1];
            visited.add(cur);
            for (int next : adjMap.get(cur)) { // 无向图，所有节点在哈希表均有 dest/to 节点，无需 getOrDefault
               if (visited.contains(next)) {
                  if (cur == next || next != parent) return true;
               } else {
                  queue.add(new int[]{cur, next});
               }
            }
         }
         return false;
      } else { // 有向图
         // [拓扑排序卡恩算法](./拓扑排序.md)
      }
   }
}
```
