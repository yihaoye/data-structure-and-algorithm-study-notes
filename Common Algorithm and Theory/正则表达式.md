# Regular Expression

工具：https://regex101.com/  

## 语言内置
* [Java Regex](../Tool%20Sets/Regex.java)  

## 例题
* [LC Q10](../Leetcode%20Practices/algorithms/hard/10%20Regular%20Expression%20Matching.java)

## 进阶功能
* [正则回溯](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/backtracking-in-regular-expressions)
  * [正则回溯陷阱](https://www.zhouhua.site/2015/trap/) - 属于 [ReDoS 漏洞](https://en.wikipedia.org/wiki/ReDoS)
    * 静态检测（如 RXXR2）、模糊测试（如 ReScue）
    * 限制回溯次数（或设置超时）
    * 避免或限制滥用贪婪通配符、分组、分支结构，警惕和减少嵌套的量词
      * 进行贪婪优化 - 如使用限定重复次数的方式、使用非贪婪词懒惰模式、使用排除型字符组消除回溯、通过断言实现多字符的排除
      * 使用原子组
      * 尽量避免使用过于复杂的分支结构
    * 使用基于 Thompson NFA 的正则引擎，实现例子如 Google RE2 等，代价是会有一些灵活的功能无法使用

参考：  
https://www.regular-expressions.info/catastrophic.html  
https://juejin.cn/post/7002921291845992484  

## 正则引擎
* [Google RE2](https://github.com/google/re2/wiki/WhyRE2)
  * [Golang Regex](https://swtch.com/~rsc/regexp/regexp2.html)


### DFA vs NFA (by ChatGPT)
DFA（确定性有限状态自动机）和NFA（非确定性有限状态自动机）都可以用于实现正则表达式，但通常更常用的是NFA。这是因为NFA相对于DFA在表示某些正则表达式的特定模式时更加简洁和灵活。

#### 为什么通常使用 NFA 而不是 DFA？
1. **灵活性：** NFA允许在给定状态和输入字符时有多个可能的下一个状态，或者可以通过空转移（ε-转移）跳转到其他状态。这种灵活性使得NFA更容易表示一些复杂的正则表达式模式，如通配符、可选项、重复等。
2. **简洁性：** 由于NFA允许多个可能的状态转移，因此通常可以用较少的状态和转移来表示同样的正则表达式。相比之下，DFA在表示某些正则表达式时可能需要更多的状态和转移，导致状态空间的爆炸。

#### DFA的局限性
尽管DFA在某些情况下具有优势，比如在匹配简单的正则表达式模式时可以更高效，但它也存在一些局限性：
1. **状态爆炸：** 对于某些复杂的正则表达式模式，DFA可能会产生状态空间爆炸，导致庞大的状态转移图，消耗大量的内存和计算资源。
2. **无法表示某些模式：** 一些复杂的正则表达式模式可能无法用DFA准确地表示，因为DFA无法处理某些非确定性的情况，比如回溯引用（backreference）等。
3. **构建复杂：** 构建一个准确的DFA来表示某些正则表达式模式可能非常困难，甚至是不可行的，因为它需要考虑所有可能的状态和转移路径。

综上所述，虽然DFA在某些情况下具有优势，但通常情况下更常用的是NFA，因为它更灵活、简洁，并且可以更准确地表示复杂的正则表达式模式。
