# Regular Expression
正则表达式  
工具：https://regex101.com/  

## 语法
* [捕获组与非捕获组](https://segmentfault.com/a/1190000021043947)

## 语言内置
* [Java Regex](../Tool%20Sets/Regex.java)  

## 例题
* [LC Q10](../Leetcode%20Practices/algorithms/hard/10%20Regular%20Expression%20Matching.java)

## 进阶功能
* [正则回溯](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/backtracking-in-regular-expressions)
  * [正则回溯陷阱](https://www.zhouhua.site/2015/trap/) - 属于 [ReDoS 漏洞](https://en.wikipedia.org/wiki/ReDoS)
  * [解决方案、最佳实践](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/best-practices-regex)
    * 静态检测（如 RXXR2）、模糊测试（如 ReScue）
    * 限制回溯次数（或设置超时）
    * 避免或限制滥用贪婪通配符、分组、分支结构，警惕和减少量词嵌套（指在正则表达式中使用一个量词例如 `*、+、?、{n}` 等来修饰另一个量词的情况）
      * 进行贪婪优化 - 如使用限定重复次数的方式、[使用非贪婪词懒惰模式](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/quantifiers-in-regular-expressions#match-zero-or-more-times-lazy-match-)、占有优先量词、量词运算、使用排除型字符组消除回溯、通过断言实现多字符的排除
      * 使用固化分组或原子分组
      * 尽量避免使用过于复杂的分支结构
    * 使用基于 Thompson NFA 的正则引擎，实现例子如 Google RE2 等，代价是放弃一些功能、特性（如回溯灾难重点元凶向后引用）
      * 其原理是仅在必要时才回溯（从而减少、避免了过多、无效回溯）以及对回溯记忆化（动态规划优化）

参考：  
https://www.regular-expressions.info/catastrophic.html  
https://juejin.cn/post/7002921291845992484  

## 正则引擎
* [Google RE2](https://github.com/google/re2/wiki/WhyRE2)
  * [Golang RE2 Thompson NFA 可以更简易且更快](https://swtch.com/~rsc/regexp/regexp1.html)
  * [虚拟机方法](https://swtch.com/~rsc/regexp/regexp2.html)
  * [Production Implementation](https://swtch.com/~rsc/regexp/regexp3.html)

### DFA vs NFA (by ChatGPT)
DFA（确定性有限状态自动机）和NFA（非确定性有限状态自动机）都可以用于实现正则表达式，但通常更常用的是NFA。这是因为NFA相对于DFA在表示某些正则表达式的特定模式时更加简洁和灵活。

#### 为什么通常使用 NFA 而不是 DFA？
1. **灵活性：** NFA允许在给定状态和输入字符时有多个可能的下一个状态，或者可以通过空转移（ε-转移）跳转到其他状态。这种灵活性使得NFA更容易表示一些复杂的正则表达式模式，如通配符、可选项、重复等。
2. **简洁性：** 由于NFA允许多个可能的状态转移，因此通常可以用较少的状态和转移来表示同样的正则表达式。相比之下，DFA在表示某些正则表达式时可能需要更多的状态和转移，导致状态空间的爆炸。

#### DFA的局限性
尽管DFA在某些情况下具有优势，比如在匹配简单的正则表达式模式时可以更高效，但它也存在一些局限性：
1. **状态爆炸：** 对于某些复杂的正则表达式模式，DFA可能会产生状态空间爆炸，导致庞大的状态转移图，消耗大量的内存和计算资源。
2. **无法表示某些模式：** 一些复杂的正则表达式模式可能无法用DFA准确地表示，因为DFA无法处理某些非确定性的情况，比如回溯引用（backreference）等。
3. **构建复杂：** 构建一个准确的DFA来表示某些正则表达式模式可能非常困难，甚至是不可行的，因为它需要考虑所有可能的状态和转移路径。

DFA（确定性有限状态自动机）通常不能直接实现一些高级特性，如贪婪通配符、分组等。这是因为DFA的状态转移是完全确定的，不具有NFA那种灵活的非确定性特性。  
一些复杂的正则表达式特性需要考虑多个可能的匹配路径，而DFA只能选择一条确定的路径。举例来说：
1. **贪婪通配符：** 贪婪通配符（如`*`和`+`）允许匹配尽可能多的字符，而不是最少的字符。实现贪婪通配符需要在匹配过程中考虑到可能的所有匹配路径，但DFA只能选择一条路径进行匹配。
2. **分组：** 分组允许将子模式进行分组，并在后续的匹配中引用这些子模式。实现分组需要在匹配过程中维护分组的信息，并在匹配过程中进行回溯等操作，但DFA并不直接支持这种操作。

因此，对于具有这些高级特性的正则表达式模式，通常会使用NFA来实现。NFA具有灵活的非确定性特性，能够更容易地表示和匹配复杂的正则表达式模式。  
综上所述，虽然DFA在某些情况下具有优势，但通常情况下更常用的是NFA，因为它更灵活、简洁，并且可以更准确地表示复杂的正则表达式模式。
