# Regular Expression
正则表达式  
工具：https://regex101.com/  

## 语法
* [捕获组与非捕获组](https://segmentfault.com/a/1190000021043947)

## 语言内置
* [Java Regex](../Tool%20Sets/Regex.java)  

## 例题
* [LC Q10](../Leetcode%20Practices/algorithms/hard/10%20Regular%20Expression%20Matching.java)

## 进阶功能
* [正则回溯](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/backtracking-in-regular-expressions) - 其实可以理解为暴力解
  * [正则回溯陷阱](https://www.zhouhua.site/2015/trap/) - 属于 [ReDoS 漏洞 | 正则表达式拒绝服务攻击](https://en.wikipedia.org/wiki/ReDoS)
  * [解决方案、最佳实践](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/best-practices-regex)
    * 静态检测（如 RXXR2）、模糊测试（如 ReScue）
    * 限制回溯次数（或设置超时）
    * 避免或限制滥用贪婪通配符、分组、分支结构，警惕和减少量词嵌套（指在正则表达式中使用一个量词例如 `*、+、?、{n}` 等来修饰另一个量词的情况）
      * 进行贪婪优化 - 如使用限定重复次数的方式、[使用非贪婪词懒惰模式](https://learn.microsoft.com/zh-cn/dotnet/standard/base-types/quantifiers-in-regular-expressions#match-zero-or-more-times-lazy-match-)、占有优先量词、量词运算、使用排除型字符组消除回溯、通过断言实现多字符的排除
      * 使用固化分组或原子分组
      * 尽量避免使用过于复杂的分支结构
    * 使用基于 Thompson NFA 的正则引擎，实现例子如 Google RE2（RE2 对于复杂的正则表达式和长字符串的匹配性能更为可靠。这在处理大规模文本或具有复杂匹配逻辑的正则表达式时尤为显著）；或禁用回溯模式，如 C# 的 RegexOptions.NonBacktracking
      * 其原理是完全不使用回溯以避免回溯灾难（因此不支持一些当前仅能通过回溯方法实现的功能特性，如 backreferences 和 look-around assertions，并建议需要时通过其他方案、组合绕过 - 另外 backreferences 是一个 NPC 问题），以及从 NFA 构造出 DFA 并缓存/记忆化（因为 DFA 比 NFA 更快，并设置内存限制，在空间不足时删除掉一些缓存，因此整个构造过程是动态的 / on the fly）来实现其他功能特性；传统的正则引擎使用回溯来处理匹配（基于纯 NFA），这意味着在匹配失败时可能需要不断回溯尝试不同的路径。而 RE2 的 NFA->DFA 构造方式通过确定性的状态转移避免了回溯，从而消除了回溯导致的性能问题
      * 另外优化了状态转移，使得在匹配时只需沿着确定性路径前进
      * RE2 通过预先计算和优化，能够在构造阶段就生成紧凑且高效的状态转移表，这样在匹配时能够以常量时间找到下一个状态，减少了运行时的计算开销
  * 一些正则引擎对回溯记忆化，属于动态规划思想，防止时间上的指数爆炸，但是相反地容易造成空间爆栈

参考：  
https://www.regular-expressions.info/catastrophic.html  
https://juejin.cn/post/7002921291845992484  

## 正则引擎
* [Google RE2](https://github.com/google/re2/wiki/WhyRE2)
  * [Golang RE2 Thompson NFA 可以更简易且更快](https://swtch.com/~rsc/regexp/regexp1.html)
  * [虚拟机方法](https://swtch.com/~rsc/regexp/regexp2.html)
  * [Production Implementation](https://swtch.com/~rsc/regexp/regexp3.html)
* https://www.abstractsyntaxseed.com/blog/regex-engine/nfa-vs-dfa

### DFA vs NFA (by ChatGPT)
DFA（确定性有限状态自动机）和NFA（非确定性有限状态自动机）都可以用于实现正则表达式，但通常更常用的是NFA。这是因为NFA相对于DFA在表示某些正则表达式的特定模式时更加简洁和灵活。

#### 为什么通常使用 NFA 而不是 DFA？
1. **灵活性：** NFA允许在给定状态和输入字符时有多个可能的下一个状态，或者可以通过空转移（ε-转移）跳转到其他状态。这种灵活性使得NFA更容易表示一些复杂的正则表达式模式，如通配符、可选项、重复等。
2. **简洁性：** 由于NFA允许多个可能的状态转移，因此通常可以用较少的状态和转移来表示同样的正则表达式。相比之下，DFA在表示某些正则表达式时可能需要更多的状态和转移，导致状态空间的爆炸。

#### DFA的局限性
尽管DFA在某些情况下具有优势，比如在匹配简单的正则表达式模式时可以更高效，但它也存在一些局限性：
1. **状态爆炸：** 对于某些复杂的正则表达式模式，DFA可能会产生状态空间爆炸，导致庞大的状态转移图，消耗大量的内存和计算资源。
2. **无法表示某些模式：** 一些复杂的正则表达式模式可能无法用DFA准确地表示，因为DFA无法处理某些非确定性的情况，比如回溯引用（backreference）等。
3. **构建复杂：** 构建一个准确的DFA来表示某些正则表达式模式可能非常困难，甚至是不可行的，因为它需要考虑所有可能的状态和转移路径。

DFA（确定性有限状态自动机）通常不能直接实现一些高级特性，如贪婪通配符、分组等。这是因为DFA的状态转移是完全确定的，不具有NFA那种灵活的非确定性特性。  
一些复杂的正则表达式特性需要考虑多个可能的匹配路径，而DFA只能选择一条确定的路径。举例来说：
1. **贪婪通配符：** 贪婪通配符（如`*`和`+`）允许匹配尽可能多的字符，而不是最少的字符。实现贪婪通配符需要在匹配过程中考虑到可能的所有匹配路径，但DFA只能选择一条路径进行匹配。
2. **分组：** 分组允许将子模式进行分组，并在后续的匹配中引用这些子模式。实现分组需要在匹配过程中维护分组的信息，并在匹配过程中进行回溯等操作，但DFA并不直接支持这种操作。

因此，对于具有这些高级特性的正则表达式模式，通常会使用NFA来实现。NFA具有灵活的非确定性特性，能够更容易地表示和匹配复杂的正则表达式模式。  
综上所述，虽然DFA在某些情况下具有优势，但通常情况下更常用的是NFA，因为它更灵活、简洁，并且可以更准确地表示复杂的正则表达式模式。
