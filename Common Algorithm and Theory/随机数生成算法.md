# 随机数生成
随机数生成算法是很多重要算法的基础，比如洗牌算法和所有的随机化算法。  
在计算机科学中，通常使用[伪随机数生成器（PRNG）](https://en.wikipedia.org/wiki/Pseudorandom_number_generator)来生成随机数，这些生成器的质量受到广泛的研究和评估，以确保它们的随机性足够高，适用于各种应用，包括加密和安全应用。如果需要更高质量的随机数，可以使用专用的硬件随机数生成器。  

## 真随机
真随机无法通过计算机程序实现，通常产生真随机需要采用[硬件随机数生成器](https://zh.wikipedia.org/wiki/%E7%A1%AC%E4%BB%B6%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8)，是一种通过物理过程而不是计算机程序来生成随机数的设备。这样的设备通常是基于一些能生成低等级、统计学随机的 “噪声” 信号的微观现象，如热力学噪声、光电效应和[量子现象](https://learn.microsoft.com/zh-cn/azure/quantum/tutorial-qdk-quantum-random-number-generator?tabs=tabid-copilot)。这些物理过程在理论上是完全不可预测的，并且已经得到了实验的证实。  
硬件随机数生成器通常每秒只能产生很有限的随机比特，这意味着它是相对较慢的。为了提高数据产生效率，它们都常被用来生成伪随机数生成器的 “种子”，并以此生成伪随机的输出序列。  

## 伪随机
转载自：https://houbb.github.io/2019/02/26/java-random  

### 什么是伪随机数？
1. 伪随机数是看似随机实质是固定的周期性序列，也就是有规则的随机。
2. 只要这个随机数是由确定算法生成的，那就是伪随机，只能通过不断算法优化，使你的随机数更接近随机。(随机这个属性和算法本身就是矛盾的)
3. 通过真实随机事件取得的随机数才是真随机数。

### Java 随机数产生原理：
**Java 的随机数产生是通过[线性同余（LCG）](https://zh.wikipedia.org/wiki/%E7%B7%9A%E6%80%A7%E5%90%8C%E9%A4%98%E6%96%B9%E6%B3%95)公式产生的，也就是说通过一个复杂的算法生成的，该方法目前不被认为是高质量的随机数生成算法，不建议在敏感场景下使用。从 Java 17 开始 Java 对其随机数生成算法进行升级。**  

### 伪随机数的不安全性：
Java 自带的随机数函数是很容易被黑客破解的，因为黑客可以通过获取一定长度的随机数序列来推出你的 seed，然后就可以预测下一个随机数。  

### Random
java.util.Random 类中实现的随机算法是伪随机，也就是有规则的随机，所谓有规则的就是在给定种 (seed) 的区间内随机生成数字；  
相同种子数的 Random 对象，相同次数生成的随机数字是完全相同的；  
Random 类中各方法生成的随机数字都是均匀分布的，也就是说区间内部的数字生成的几率均等；  

### ThreadLocalRandom
如果想兼顾性能，那么使用这个类代替 Random。  
这个类是 Java 7 新增的类，给多线程并发生成随机数使用的。  

为什么 ThreadLocalRandom 要比 Random 快呢？  
这是因为 Random 在生成随机数的时候使用了 CAS（compare and set），但是 ThreadLocalRandom 却没有使用。  

### SecureRandom
在需要频繁生成随机数，或者安全要求较高的时候，不要使用 Random，这个很好理解吧，从最开始的介绍中可以知道，Random 生成的值其实是可以预测的。  
内置两种随机数算法，NativePRNG 和 SHA1PRNG，看实例化的方法了。通过 new 来初始化，默认来说会使用 NativePRNG 算法生成随机数，但是也可以配置 -Djava.security 参数来修改调用的算法。如果是 `/dev/[u]random` 两者之一就是 NativePRNG，否则就是 SHA1PRNG。  
在 jvm 启动参数这样加就好了，`-Djava.security=file:/dev/urandom`。  

还可以通过 getInstance 来初始化对象，有一个参数的，直接传一个算法名就行，如果不存在算法抛异常；另外有两个参数的，第二个参数还可以指定算法程序包。下面来看下实现代码：  
```java
SecureRandom secureRandom = new SecureRandom();
SecureRandom secureRandom3 = SecureRandom.getInstance("SHA1PRNG");
SecureRandom secureRandom2 = SecureRandom.getInstance("SHA1PRNG", "SUN");
```  

当然使用这个类去生成随机数的时候，一样只需要生成一个实例每次去生成随机数就好了，也没必要每次都重新生成对象。另外，这个类生成随机数，首次调用性能比较差，如果条件允许最好服务启动后先调用一下 nextInt()。  
另外，实际上 SHA1PRNG 的性能将近要比 NativePRNG 的性能好一倍，synchronized 的代码少了一半，所以没有特别重的安全需要，尽量使用 SHA1PRNG 算法生成随机数。  

### Math.random
这也是个比较常用的生成随机数的方式,默认生成 0~1 之间的小数.  

### 总结
1. 单机中如果对安全性要求不高的情况下，使用 Random；对安全性要求高，就用 SecureRandom；SecureRandom 里有两种算法，SHA1PRNG 和 NativePRNG，SHA1PRNG 的性能好，但是 NativePRNG 的安全性高。
2. Random 是线程安全的，用 CAS 来保持，但是性能比不高，所以多线程中，尽量使用 java 并发包里的 ThreadLocalRandom，避免了线程之间的竞争导致的性能问题。


## 其他
### 可否使用（触发）时间来进行随机生成？
基于时间戳的随机数生成方法不是真正的随机数生成器。这是因为在计算机中，随机数的生成实际上是一个确定性的过程，完全取决于初始状态（种子）和生成算法。虽然从外部看起来可以看作是随机的，但实际上是一种伪随机性。以下是为什么不使用时间戳来生成随机数的一些原因：
* 可预测性：基于时间戳生成的随机数是可预测的，因为它们受到时间的连续性影响。如果知道了生成随机数的时间，可能可以预测下一个随机数。这在许多应用中是不可接受的，尤其是在安全和加密领域。
* 周期性：基于时间戳生成的随机数会受到时间戳周期性重复的影响。例如，如果每秒生成一个随机数，那么在一秒的时间内，最多只能得到 60 个不同的值，之后将会重复。
* 种子问题：生成随机数的质量取决于种子的选择。如果两个应用程序使用相同的种子，它们将生成相同的随机数序列。而种子的选择通常是不可控的，因此不适合用于高度安全性要求的应用。

