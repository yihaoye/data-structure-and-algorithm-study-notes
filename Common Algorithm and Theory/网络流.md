# 网络流
转载自：https://www.cnblogs.com/imreW/p/17396308.html  

网络流是算法中的一个重要的模型，它分为两部分：网络和流。  
网络，其实就是一张有向图，其上的边权称为容量。额外地，它拥有一个源点和汇点。  

![](./Flow-Network.png)  

流，顾名思义，就像水流或电流，也具有它们的性质。如果把网络想象成一个自来水管道网络，那流就是其中流动的水。每条边上的流不能超过它的容量，并且对于除了源点和汇点外的所有点（即中继点），流入的流量都等于流出的流量。  
网络流中最常见的问题就是网络最大流。假定从源点流出的流量足够多，求能够流入汇点的最大流量。例如对上面那张网络而言，最大流是 5，其中 1->3 提供 2 流量，1->2->3 提供 2 流量（这有点像木桶原理，某条路径的容量是由最窄的一根水管决定的），1->2->4->3 提供 1 流量（注意这里不是 2，因为上条路径已经占用了 1->2 的 2 单位容量，只剩 1 单位容量可用）。  

解决这个问题最常用的是 Ford-Fulkerson 算法及其优化法。  

## Ford-Fulkerson 算法
FF算法的核心在于找增广路。何谓增广路？例如上图中首先选择 1->2->3，这是一条增广路，提供 2 流量；然后相应地扣除选择路径上各边的容量，1->2 的容量变成 1，2->3 的容量变成 0，这时的容量称为残余容量。然后再找到 1->2->4->3 这条路径，按残余容量计算流量，它提供 1 流量（选择这两条路的顺序可以颠倒）。1->2->4->3 也是一条增广路。  
增广路，是从源点到汇点的路径，其上所有边的残余容量均大于 0。FF 算法就是不断寻找增广路，直到找不到为止。但是这个算法在一些情况下不一定是正确的。  

## Dinic 算法
网络流算法中实际最常使用。作为 FF/EK 算法的优化，它选择了先用 BFS 分层，再用 DFS 寻找。它的时间复杂度上界是 O(ev^2)，其中 e 为边数，v 为点数。  
```java
public class Dinic {
    static final int MAXN = 1000; // Adjust the size as needed
    static final int INF = Integer.MAX_VALUE;
    int n, m, s, t;
    int[] lv = new int[MAXN]; int[] cur = new int[MAXN];
    List<Edge>[] adj = new List[MAXN];

    public Dinic(int n, int s, int t) {
        this.n = n; this.s = s; this.t = t;
        for (int i = 0; i < MAXN; i++) adj[i] = new ArrayList<>();
    }

    static class Edge {
        int to, rev, w;
        public Edge(int to, int rev, int w) {
            this.to = to; this.rev = rev; this.w = w;
        }
    }

    void addEdge(int from, int to, int w) {
        adj[from].add(new Edge(to, adj[to].size(), w));
        adj[to].add(new Edge(from, adj[from].size() - 1, 0));
    }

    boolean bfs() {
        Arrays.fill(lv, -1);
        lv[s] = 0;
        Queue<Integer> q = new LinkedList<>();
        q.add(s);
        while (!q.isEmpty()) {
            int p = q.poll();
            for (Edge e : adj[p]) {
                if (e.w > 0 && lv[e.to] == -1) {
                    lv[e.to] = lv[p] + 1;
                    q.add(e.to);
                }
            }
        }
        return lv[t] != -1;
    }

    int dfs(int p, int flow) {
        if (p == t) return flow;

        int rmn = flow;
        for (int i = cur[p]; i < adj[p].size(); i++) {
            cur[p] = i;
            Edge e = adj[p].get(i);
            if (e.w > 0 && lv[e.to] == lv[p] + 1) {
                int c = dfs(e.to, Math.min(e.w, rmn));
                if (c > 0) {
                    e.w -= c;
                    adj[e.to].get(e.rev).w += c;
                    rmn -= c;
                    if (rmn == 0) break;
                }
            }
        }
        return flow - rmn;
    }

    int dinic() {
        int ans = 0;
        while (bfs()) {
            Arrays.fill(cur, 0);
            ans += dfs(s, INF);
        }
        return ans;
    }

    public static void main(String[] args) {
        Dinic dinic = new Dinic(6, 0, 5); // number of nodes, srouce, sink
        // Add edges
        dinic.addEdge(0, 1, 10); dinic.addEdge(0, 2, 10); dinic.addEdge(1, 3, 4); dinic.addEdge(1, 4, 8);
        dinic.addEdge(1, 2, 2); dinic.addEdge(2, 4, 9); dinic.addEdge(3, 5, 10); dinic.addEdge(4, 3, 6); dinic.addEdge(4, 5, 10);

        System.out.println("The maximum possible flow is " + dinic.dinic());
    }
}
```

## 应用
网络流算法在计算机科学和工程中有广泛的应用，特别是在解决涉及流量分配、资源优化和图论的问题时。以下是一些常见的应用场景：

1. 最大流问题
   * 交通流量优化：在交通网络中，最大流算法可以用于优化交通流量，减少拥堵。
   * 通信网络：在计算机网络中，用于优化数据包的路由，确保网络带宽的最优利用。
   * 供水网络：在城市供水系统中，用于最大化从水源到用户的供水量。
2. 最小割问题
   * 图像分割：在计算机视觉中，用于图像分割，将图像分割成前景和背景部分。
   * 社区检测：在社交网络分析中，用于检测社区或群体，通过最小割来找到社交网络中的紧密子集。
3. 匹配问题
   * 二分图最大匹配：在任务分配、婚配问题中，用于找到最大匹配，例如，在公司员工和任务之间分配任务。
   * 稳定婚姻问题：在稳定婚姻问题中，使用网络流算法可以找到一种稳定的婚配方式。
4. 可行流问题
   * 物流和供应链管理：在物流网络中，用于确定从多个供应商到多个需求点的最优货物流动。
   * 电力网络：在电力传输网络中，用于优化电力从发电站到各个地区的传输。
5. 最小费用最大流问题
   * 运输问题：在运输网络中，确定最小成本的货物运输方案。
   * 任务调度：在任务调度问题中，确定在最小成本下完成所有任务的方案。
6. 其他应用
   * 项目选择和投资：在项目管理中，用于选择一组项目，使得总收益最大化。
   * 信息流分析：在信息传播模型中，用于分析信息在社交网络中的传播路径和效率。
   * 医疗资源分配：在医疗系统中，用于优化医疗资源（如医生、设备）的分配，以满足患者需求。
