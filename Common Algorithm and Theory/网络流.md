# 网络流
转载自：https://www.cnblogs.com/imreW/p/17396308.html  

网络流是算法中的一个重要的模型，它分为两部分：网络和流。  
网络，其实就是一张有向图，其上的边权称为容量。额外地，它拥有一个源点和汇点。  

![](./Flow-Network.png)  

流，顾名思义，就像水流或电流，也具有它们的性质。如果把网络想象成一个自来水管道网络，那流就是其中流动的水。每条边上的流不能超过它的容量，并且对于除了源点和汇点外的所有点（即中继点），流入的流量都等于流出的流量。  
网络流中最常见的问题就是网络最大流。假定从源点流出的流量足够多，求能够流入汇点的最大流量。例如对上面那张网络而言，最大流是 5，其中 1->3 提供 2 流量，1->2->3 提供 2 流量（这有点像木桶原理，某条路径的容量是由最窄的一根水管决定的），1->2->4->3 提供 1 流量（注意这里不是 2，因为上条路径已经占用了 1->2 的 2 单位容量，只剩 1 单位容量可用）。  

解决这个问题最常用的是 Ford-Fulkerson 算法及其优化法。  

## Ford-Fulkerson 算法
FF 算法的核心在于找增广路。何谓增广路？例如上图中首先选择 1->2->3，这是一条增广路，提供 2 流量；然后相应地扣除选择路径上各边的容量，1->2 的容量变成 1，2->3 的容量变成 0，这时的容量称为残余容量。然后再找到 1->2->4->3 这条路径，按残余容量计算流量，它提供 1 流量（选择这两条路的顺序可以颠倒）。1->2->4->3 也是一条增广路。  
增广路，是从源点到汇点的路径，其上所有边的残余容量均大于 0。FF 算法就是不断寻找增广路，直到找不到为止。但是这个算法在一些情况下不一定是正确的。  

## Dinic 算法
网络流算法中实际最常使用。作为 FF/EK 算法的优化，它选择了先用 BFS 分层，再用 DFS 寻找。它的时间复杂度上界是 O(E*V^2)，其中 E 为边数，V 为点数。  
```cpp
int s, t, lv[MAXN], cur[MAXN]; // // s 是源点，t 是汇点，lv 是每个点的层数，cur 用于当前弧优化标记增广起点
inline bool bfs() { // BFS 分层
    memset(lv, -1, sizeof(lv)); lv[s] = 0;
    memcpy(cur, head, sizeof(head)); // 当前弧优化初始化
    queue<int> q; q.push(s);
    while (!q.empty()) {
        int p = q.front(); q.pop();
        for (int eg = head[p]; eg; eg = edges[eg].next) {
            int to = edges[eg].to, vol = edges[eg].w; // vol i.e. volume
            if (vol > 0 && lv[to] == -1) lv[to] = lv[p] + 1, q.push(to);
        }
    }
    return lv[t] != -1; // 如果汇点未访问过说明已经无法达到汇点，此时返回 false
}
int dfs(int p = s, int flow = INF) {
    if (p == t) return flow;
    int rmn = flow; // 剩余的流量 remain
    for (int eg = cur[p]; eg && rmn; eg = edges[eg].next) { // 如果已经没有剩余流量则退出
        cur[p] = eg; // 当前弧优化，更新当前弧
        int to = edges[eg].to, vol = edges[eg].w;
        if (vol > 0 && lv[to] == lv[p] + 1) { // 往层数高的方向增广
            int c = dfs(to, min(vol, rmn)); // 尽可能多地传递流量
            rmn -= c; // 剩余流量减少
            edges[eg].w -= c; // 更新残余容量
            edges[eg ^ 1].w += c; // 再次提醒，链式前向星的 cnt 需要初始化为 1（或-1）才能这样求反向边
        }
    }
    return flow - rmn; // 返回传递出去的流量的大小
}
inline int dinic() {
    int ans = 0;
    while (bfs()) ans += dfs();
    return ans;
}
```

## 应用
网络流算法在计算机科学和工程中有广泛的应用，实用且重要，特别是在解决涉及资源分配、流量/运输优化和图论的问题时。以下是一些常见的应用场景：

1. 最大流问题（最小费用）
   * 交通流量优化：在交通网络中，最大流算法可以用于优化交通流量，减少拥堵。或确定最小成本的货物运输方案。在物流和供应链网络中的可行流问题，用于确定从多个供应商到多个需求点的最优货物流动。
   * 通信、供水、供电网络：在计算机网络中，用于优化数据包的路由，确保网络带宽的最优利用。在城市供水系统中，用于最大化从水源到用户的供水量。在电力传输网络中，用于优化电力从发电站到各个地区的传输。
   * 任务调度：在任务调度问题中，确定在最小成本下完成所有任务的方案。
2. 最小割问题
   * 图像分割：在计算机视觉中，用于图像分割，将图像分割成前景和背景部分。
   * 社区检测：在社交网络分析中，用于检测社区或群体，通过最小割来找到社交网络中的紧密子集。
3. 匹配问题
   * 二分图最大匹配：在任务分配、婚配问题中，用于找到最大匹配，例如，在公司员工和任务之间分配任务。
   * 稳定婚姻问题：在稳定婚姻问题中，使用网络流算法可以找到一种稳定的婚配方式。
4. 其他应用
   * 项目选择和投资：在项目管理中，用于选择一组项目，使得总收益最大化。
   * 信息流分析：在信息传播模型中，用于分析信息在社交网络中的传播路径和效率。
   * 医疗资源分配：在医疗系统中，用于优化医疗资源（如医生、设备）的分配，以满足患者需求。
