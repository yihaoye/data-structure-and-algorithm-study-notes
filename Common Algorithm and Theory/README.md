## 算法与理论 | Algorithms and Theory

This personal Blog contains explanation and **Java library/template implementation of some Advanced Algorithms**. For Advanced Data Structure library implementation, please check [here](../Common%20Data%20Structure%20and%20Data%20Type/README.md).  
  
- 理论与概念 | Theory and Concept ([Wiki](https://oi-wiki.org/misc/cc-basic/))
  - [时空复杂度 | Time and Space Complexity](./时空复杂度.md)
  - [算法分析初步 | Algorithm Analysis](../算法竞赛入门经典/README.md)
    - 渐进分析 | Asymptotic Analysis
    - 平摊分析 | Amortized Analysis
    - 随机算法分析 | Random Algorithm Analysis (涉及到概率和期望值的计算)
  - [多项式时间 | Polynomial Time](./多项式时间.md)
  - [搜索 | Search](./搜索.md)
  - [在线/离线算法 | Online/Offline Algorithm](./在线离线算法.md)
  - 离散与连续 (数据集) | Discrete and Continuous
- 算法分析工具 | Algorithm Analysis Tools
  - [递归树 | Recursion Tree](./递归树.md)
  - 循环不变量 | Loop Invariants (本质上是数学归纳法)
- 算法 | Algorithms
  - 基础与思维 | Foundation and Thought
    - [排序 (常用排序算法) | Sorting](./Common%20Sorts/README.md) - 排序算法选择除了考虑数量级、复杂度稳定性之外，有时应该注意场景，比如可以肯定永远是只求一个极值的情况下，最简单的一轮冒泡算法反而是最好的
    - [枚举/穷举 | Enumerate](./枚举(穷举)算法.md)
    - [模拟 | Simulation](./模拟算法.md)
    - [递归, 迭代 | Recursion, Iteration](./递归与迭代.md)
    - [分治法 | Divide-and-Conquer](./分治法.md) (通常被认为一种方案思路或算法范型而非具体算法，时间复杂度不固定，比如快速幂的开方分解则为 `O(logN)`，而更通常的线性分解则为 `O(N)` 或 `O(N*f(N))` 或 `O(N*logN)` 比如归并排序，其他分解情况下亦有可能是其他大 O) ([分治法与二分算法的区别](./分治法.md#分治法-vs-二分算法))
    - 推理 | Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%8E%A8%E7%90%86))
      - 演绎法 | Deductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86)；Dynamic Programming 或任意 Top-Down、Bottom-Up 的算法都基于此法)
      - 溯因法 | Abductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86)；常用于 debug 和改善性能)
      - 归纳法 | Inductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E5%BD%92%E7%BA%B3%E6%8E%A8%E7%90%86)；可用于基于测试数据的输入输出案例进行目标算法逻辑的先期猜测、过滤)
  - 中阶 | Intermediate
    - [二分搜索/二分算法 | Binary Search](./二分搜索.md) (时间复杂度 `O(logN)`)
      - 插值搜索 | Interpolation Search (时间复杂度平均 `O(log(logN))` 最坏 `O(N)`，对于数据量较大、关键字分布比较均匀的查找表来说速度较快，关键字分布不均匀的情况下，该方法不如折半查找稳定 [Ref](https://zq99299.github.io/dsalg-tutorial/dsalg-java-hsp/08/03.html#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95))
      - 斐波那契搜索 | Fibonacci Search (时间复杂度 `O(logN)`，与折半查找性能差不多，在早期除法性能较差的硬件上比折半查找略优 [Ref](https://blog.csdn.net/weixin_42145502/article/details/99676008))
    - [双指针法, 滑动窗口算法 | Two Pointer, Sliding Window](./双指针法与滑动窗口算法.md)
    - [深度优先, 广度优先, 树图遍历 | Depth First Search, Breadth First Search](./树图遍历.md)
      - [回溯法 | Backtracking](./回溯法.md) (回溯法通常用于解决 NP 问题 i.e. 非确定性多项式问题)
      - 双向搜索/中途相遇 | Bidirectional-Search/Meet-in-the-Middle-Search ([Wiki](https://oi-wiki.org/search/bidirectional/))
      - DSW 算法 | Day–Stout–Warren Algorithm ([Ref](https://developer.baidu.com/article/details/3061860)；基本思想是将任意的二叉查找树转换为类似于链表的树，称为主链或主干。通过旋转操作，将二叉查找树转换为平衡状态，然后使用中序遍历将元素放入数组中，最后重建该树。这个过程可以在 `O(N)` 时间内完成)
    - [贪心算法 | Greedy Algorithm](./贪婪算法.md)
      - [耐心排序 | Patience Sorting](./耐心排序.md)
      - [摩尔投票 | Boyer–Moore Majority Vote Algorithm](../Leetcode%20Practices/algorithms/easy/169%20Majority%20Element.java) ([Wiki](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95)，仅局限适用于有某元素得票数大于 1/2 的场景)
      - [Sunday 算法 | Sunday Algorithm](./sunday_search.py) (字符串匹配，比 KMP 简单，平均时间复杂度 `O(N+M)`，最差时间复杂度 `O(N*M)`)
    - [拓扑排序 | Topological Sorting](./拓扑排序.md) (时间复杂度 `O(N)`)
    - [单调栈 (包括单调队列) | Monotone Stack](./单调栈.md) (时间复杂度 `O(N)`)
    - [自定义哈希/指纹 | Customized HashCode/FingerPrint](./自定义哈希指纹.md) (时间复杂度 `O(N)`)
      - 哈希碰撞 | Hash Collision ([Ref 1](https://www.cnblogs.com/east7/p/12594894.html)、[Ref 2](https://www.cnblogs.com/heyanan/p/6912870.html))
        - 开放寻址法 | Open Addressing
        - 链地址法（拉链法）| Separate Chaining (Java 等多数编程语言的哈希表实现采用该方法，因为其删除操作比开放寻址法简便)
      - [滚动哈希 | Rolling Hash (Rabin-Karp)](./滚动哈希.md) (时间复杂度 `O(N+M)`)
      - [哈希表多键索引 | HashMap Composite Key](./哈希表多键索引.md)
    - [快速选择 (霍尔选择算法) | Quickselect (Randomized Selection)](./快速选择.md)
    - [位运算 | Bitwise Operation](./位运算.md)
    - [洗牌算法 | Knuth-Shuffle](./../Leetcode%20Practices/algorithms/medium/384%20Shuffle%20an%20Array.java)
  - 进阶 | Advanced
    - [动态规划, 状态机 | Dynamic Programming, State Machine](./动态规划与状态机.md) (动态规划本质上属于分治法的应用，并在分治法之上增加了通过空间缓存子问题结果以避免重复计算的优化，即只适用于有重复子问题的问题，因为有些问题分治后每个子问题都是独立不重复的)
      - [前缀和, 差分, 树状数组, 线段树 | Prefix Sum, Difference, Binary Indexed Tree, Segment Tree](./前缀和与差分.md)
      - [记忆化搜索 | Memory Search](./记忆化搜索.md)
      - [位掩码 | Bitmasking](./动态规划与状态机.md#位掩码-dp)
      - [编辑距离 | Edit Distance](./编辑距离.md) ([Wiki](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%BC%AF%E8%B7%9D%E9%9B%A2)，[Code](../Leetcode%20Practices/algorithms/hard/72%20Edit%20Distance.java)；常用比如莱文斯坦距离)
      - [倍增法 | Binary Lifting](./倍增法.md) (时间复杂度 - 预处理 `O(N*logN)`，之后查询 `O(logN)`) ([倍增法与二分法的区别](./倍增法.md#二分-vs-倍增))
      - [弗洛伊德算法 | Floyd-Warshall Algorithm](./弗洛伊德算法.md) (时间复杂度 `O(N^3)`)
      - [Kadane 算法 | Kadane's Algorithm](./Kadane算法.md) (时间复杂度 `O(N)`，空间复杂度 `O(1)`)
      - [马拉车算法 | Manacher Algorithm](./马拉车算法.md) (时间复杂度 `O(N)`)
      - 词法与语法分析 | Lexical & Syntactic Analysis ([Wiki 1](https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)、[Wiki 2](https://zh.wikipedia.org/wiki/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90)、[语义分析](https://en.wikipedia.org/wiki/Semantic_analysis_(linguistics))、[Simple Example: JSON Parser](../Leetcode%20Practices/object%20oriented%20design/other%20practices/json%20parser/README.md))
        - [抽象语法树 | Abstract Syntax Tree (AST)](https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9)
        - [正则表达式 | Regular Expression](./正则表达式.md) (正则引擎是基于自动机的)
      - [自动机 | Automaton](./自动机.md) ([Wiki](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8B%95%E6%A9%9F%E7%90%86%E8%AB%96)；有 DFA、NFA 两种类别，实际上 DFA 与 NFA 是形式理论等价的、可互相转换的)
        - [确定性有限状态自动机 | Deterministic Finite Automaton (DFA)](../Tool%20Sets/FSM(DFA).java) ([Wiki](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA))
          - [KMP 算法 | Knuth–Morris–Pratt Algorithm](./KMP算法.md) (时间复杂度 `O(N+M)`)
          - [AC 自动机 | Aho–Corasick Algorithm](./AC自动机.md) (时间复杂度 - 构建自动机 `O(M)`，其中 M 是模式串总长度；匹配文本为 `O(N)`，其中 N 是文本串长度)
        - [非确定性有限状态自动机 | Nondeterministic Finite Automaton (NFA)](../Tool%20Sets/FSM(NFA).java) ([Wiki](https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA)，相比 DFA 构造更简单、功能更强大；时间复杂度最差通常为 `O(2^N)`)
    - [并查集联合查找算法 | Disjoint-Set Union-Find Algorithm, DSU](./并查集与联合查找算法.md) (时间复杂度 `O(a(N))` - a(N) 为反阿克曼函数，对于大部分 N，a(N) 均小于 5，所以并查集的时间复杂度也可视为 `O(1)`)
    - [图匹配 | Graph Match](./图匹配.md)
      - 染色法 | Coloring Method
      - [匈牙利算法 | Hungarian Algorithm](./匈牙利算法.md) (时间复杂度 `O(N^3)`)
    - [最小生成树相关算法 | Minimum Spanning Tree Algorithms](./../Common%20Data%20Structure%20and%20Data%20Type/Data%20Structure%20Implementation/MinimumSpanningTree/README.md)
    - [网络流相关算法 | Flow Network Algorithms](./网络流.md) (概念：[最大流最小割](./网络流.md#最大流最小割)同时也是最优化理论的定理，[增广路 | Augmenting Path](../Common%20Algorithm%20and%20Theory/图匹配.md#增广路定理-Berge's-lemma))
      - Ford-Fulkerson 算法
        - [迪尼茨算法 | Dinic Algorithm](./网络流.md#dinic-算法) (网络流重点算法，时间复杂度 `O(E*V^2)`)
    - [迪杰斯特拉算法 | Dijkstra Algorithm](./Dijkstra算法.md) (时间复杂度：单起点单终点 `O(V'+E'*logV')` 这里的 V' 和 E' 意思是计算出结果前遍历的节点和路径，单起点到其他各点 `O((V+E)*logV)` 这里的 V 和 E 是全部的节点和路径)
    - 贝尔曼-福特算法 | Bellman-Ford Algorithm ([Ref](https://mp.weixin.qq.com/s/wnRQ_9CckAmlQaAjo7q_0w))
      - 最短路径快速算法 | Shortest Path Faster Algorithm (又称 SPFA，是带有队列优化的 Bellman-Ford 算法，最坏情况下时间复杂度为 `O(V*E)`，在特定情况下其效率优于 Dijkstra 算法，近似 `O(E)`)
    - [分层可导航小世界算法 | Hierarchical Navigable Small World Algorithm](./HNSW.md) (时间复杂度：搜索平均 `O(logN)` 最差 `O(N^(1-1/d))`，插入 `O(logN)`，其中 N 为节点数、d 为维度数)
    - 近似算法 | Approximation Algorithm ([Wiki](https://en.wikipedia.org/wiki/Approximation_algorithm))
      - 多项式时间近似算法 | Polynomial-Time Approximation Scheme (PTAS) (时间复杂度 `O(N^c1+N^c2+...)` ~= `O(N^c1)`，指数为常数)
    - [启发式算法/搜索 | Heuristic Algorithm/Search](./启发式算法.md) (启发式搜索通常不讨论时空复杂度)
      - [A&ast; 搜索算法 | A&ast; Search Algorithm](./A*搜索算法.md) ([Ref](https://theory.stanford.edu/~amitp/GameProgramming/)；基于 Dijkstra 算法添加了启发式函数，单起点单终点最坏时间复杂度：`O(V+E*logV)`)
        - IDA&ast; 算法 | IDA&ast; Algorithm
      - 禁忌搜索 | Tabu Search
      - 爬山算法 | Hill Climbing
      - [随机数生成算法 | Random Number Generator](./随机数生成算法.md) ([Xorshift RNGs](https://www.jstatsoft.org/article/view/v008i14/916))
        - [高性能大规模唯一随机数生成 | Efficient Large Unique Random Number Generator](https://github.com/yihaoye/lurand) ([Code Copy](./lurand.go))
      - 随机化算法/搜索 | Random Algorithm/Search (随机化算法高效的原因是它跳过不必要的枝节、搜索空间，即其本质是剪枝优化。另外，有些随机化算法如随机森林可以容易地并行化，因为它们的操作不一定依赖于前一步骤的结果，这使得它们在多核或分布式计算环境中更高效)
        - 蒙特卡洛方法 | Monte Carlo Method ([Ref](https://renns.top/post/59/)，采样越多，越近似最优解)
          - [模拟退火 | Simulated Annealing](./模拟退火.md)
          - [遗传算法 | Genetic Algorithm](./遗传算法.md)
          - [粒子群优化算法 | Particle Swarm Optimization](./粒子群优化算法.md)
          - 蒙特卡洛树搜索 | Monte Carlo Tree Search (用于搜索树型结构的算法，广泛应用于博弈和决策问题，如 AlphaGo)
        - 拉斯维加斯方法 | Las Vegas Method (采样越多，越可能找到最优解)
  - 系统级或领域相关 | System Level or Domain Related
    - [字典树算法 | Trie Algorithm](./../Common%20Data%20Structure%20and%20Data%20Type/Data%20Structure%20Implementation/Trie/README.md)
    - [映射-归约 | MapReduce](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md)
    - 多路归并 | K-Way Merge ([Wiki](https://en.wikipedia.org/wiki/K-way_merge_algorithm)、[Code](../Leetcode%20Practices/algorithms/hard/23%20Merge%20k%20Sorted%20Lists.java)；该算法原理基于 [Top-K 优化](./Leetcode%20Practices/algorithms/medium/692%20Top%20K%20Frequent%20Words.java)，只是多路归并通常使用更复杂的引用、索引，而简单的 Top-K 优化是基于哈希表等或完全不需要存取完整数据)
    - 环形缓冲器及其算法 | Ring Buffer ([Wiki](https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80)；注意，可以用一个最长的环实现多环复用，用一个变量或指针记录当前的长环尾部，若想获取短环则只需从长环尾部往前回溯一次短环长度再开始遍历即可)
      - [散列与分层时序轮算法 | Hashed and Hierarchical Timing Wheels Algorithm](./散列与分层时序轮.md) (操作时间复杂度皆为 `O(1)`)
    - [分块/分桶法 | Range Block/Bucketing](./分桶法.md) (若为平方分割，则时间复杂度 `O(√N)`，通常在线/离线均可使用)
      - 莫队算法 | Mo Algorithm ([Wiki](https://oi-wiki.org/misc/mo-algo/)，通常用于离线算法)
    - [蓄水池抽样算法 | Reservoir Sampling](./蓄水池抽样算法.md) (时间复杂度为 `O(N)` 且为一次遍历即可，空间复杂度 `O(m)` m 为从流中随机选出 m 个，因为 m 通常为有限的常数，所以空间复杂度可以认为是 `O(1)`)
    - 编码算法 | Coding Algorithm ([熵编码](https://zh.wikipedia.org/wiki/%E7%86%B5%E7%B7%A8%E7%A2%BC%E6%B3%95)、[字典编码](https://en.wikipedia.org/wiki/Dictionary_coder))
      - [霍夫曼压缩算法 | Huffman Coding/Compression](./霍夫曼压缩算法.md)
    - [布隆过滤器及其算法 | Bloom Filter](./布隆过滤器及其算法.md)
      - 计数布隆过滤器 | Counting Bloom Filter (支持删除操作)
      - 布谷鸟过滤器及其算法 | Cuckoo Filter (相比布隆过滤器的空间占用高一些且性能低一些，优势在于低假阳率、支持删除操作)
    - [Count-Min Sketch 算法](./Count-Min-Sketch.md) (可以替代上面的布隆过滤器以提供统计、删除功能)
      - Count-Mean-Min Sketch 算法
    - 局部敏感哈希 | Locality-Sensitive Hashing ([Wiki](https://en.wikipedia.org/wiki/Locality-sensitive_hashing))
      - 最小哈希 | MinHash ([Wiki](https://en.wikipedia.org/wiki/MinHash), [Ref 1](https://www.cnblogs.com/liuxiaochong/p/14552227.html), [Ref 2](https://ansvver.github.io/lsh_minhash.html))
      - 相似哈希 | SimHash
    - 校验和 | Checksum ([Wiki](https://zh.wikipedia.org/wiki/%E6%A0%A1%E9%AA%8C%E5%92%8C)) - 属于滚动哈希的子类别。在实际应用中比如 Rsync 同步机制 ([Wiki](https://zh.wikipedia.org/zh-cn/Rsync#%E6%BC%94%E7%AE%97%E6%B3%95)、[Ref](https://zhuanlan.zhihu.com/p/59086295)) 是复合使用多种校验和算法而实现的
      - 循环冗余校验 | Cyclic Redundancy Check ([Wiki](https://zh.wikipedia.org/wiki/%E5%BE%AA%E7%92%B0%E5%86%97%E9%A4%98%E6%A0%A1%E9%A9%97)，不可逆，CRC32 是一种用于生成 32 位循环冗余校验码的哈希函数，主要用于检测数据传输中的错误，例如文件传输、网络通信等。其计算速度快、实现简单，但安全性较低，不适用于对数据完整性要求较高的场景)
      - MD5 消息摘要算法 (性质上不可逆，但是因为原像抗性不够高所以可通过彩虹表和剪枝暴力破解造成事实上可逆，而且抗碰撞能力也不够高，所以不安全)
      - 安全哈希算法系列 | Secure Hash Algorithm (SHA) ([Wiki](https://zh.wikipedia.org/wiki/SHA%E5%AE%B6%E6%97%8F)，不可逆。安全性主要指的是它的抗碰撞能力和原像抗性，即使输入数据发生细微的变化，输出的哈希值也会发生巨大的变化，且不可能从哈希值反推出原始数据)
      - bcrypt、scrypt、Argon2 (不可逆，不仅可以用于数据完整性校验，还可以用于密码存储和验证。它们通常包含一些安全特性，如盐和工作因子，以提高抵抗暴力破解和彩虹表攻击的能力)
      - 数字签名算法 | Digital Signature Algorithm (DSA) ([Wiki](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95)，不可逆。DSA 算法包含了四种操作：密钥生成、密钥分发、签名、验证。数字签名算法可以用于身份验证，发送方使用自己的私钥对数据进行签名，接收方使用发送方的公钥对签名进行验证)
        - 椭圆曲线数字签名算法 | ECDSA (不可逆)
    - 纠错码 | Correcting Code ([Wiki](https://zh.m.wikipedia.org/wiki/%E7%BA%A0%E9%94%99%E7%A0%81)，其中[纠删码](https://en.wikipedia.org/wiki/Erasure_code)是其子集；vs 校验和：纠错码不仅可以检测错误，还能在一定程度上纠正错误，通常计算更复杂，需要更多的冗余数据，用于对数据完整性要求较高的场景如存储系统、卫星通信等)
      - 里德-所罗门码 | RS Codes ([Wiki](https://zh.m.wikipedia.org/zh-hans/%E9%87%8C%E5%BE%B7-%E6%89%80%E7%BD%97%E9%97%A8%E7%A0%81))
    - 均匀哈希 | Uniform Hash
      - MurmurHash3 (不可逆，是一种非加密哈希函数，有速度快、均匀性好、易于使用等优点，常用于哈希表、布隆过滤器等数据结构中，以提高性能和减少哈希碰撞；[Code](https://commons.apache.org/proper/commons-codec/jacoco/org.apache.commons.codec.digest/MurmurHash3.java.html))
      - xxHash (同上，是比 MurmurHash 更快的哈希算法，尤其在较大数据块的哈希运算上表现优异，[Ref](https://xxhash.com/))
    - 加密算法 | Cryptography (可逆)
      - [AES 对称加密算法](https://goodapple.top/archives/162) (可逆)
      - RSA 加密算法 (可逆，最重要的[非对称加密算法](./非对称加密算法.md))
    - [HyperLogLog 算法](./HyperLogLog.md)
    - [雪花算法 | Snowflake ID](./雪花算法.md)
    - 一致性哈希 | Consistent Hashing ([Ref](https://dgryski.medium.com/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8)) (数据操作时间复杂度为 `O(logN)`，节点增删时间复杂度为 `~O(N/M)` 其中 M 为实际节点数)
      - [环形哈希 (虚拟节点) | Ring Hashing](./../Leetcode%20Practices/system%20design/一致性哈希.md) ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/consistent%20hash/README.md))
      - 跳跃哈希 | Jump Hashing ([Ref 1](https://arxiv.org/pdf/1406.2294.pdf)、[Ref 2](https://writings.sh/post/consistent-hashing-algorithms-part-3-jump-consistent-hash))
      - Multi-Probe Consistent Hashing
      - Rendezvous Hashing ([Wiki](https://en.m.wikipedia.org/wiki/Rendezvous_hashing))
      - Maglev Hashing
    - [反向索引 | Inverted Index]((../Leetcode%20Practices/system%20design/README.md#设计搜索引擎-Twitter-Search)) ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/inverted%20index/InvertedIndex.java))
    - Frugal Streaming 算法
    - [Geohash 算法, S2 Geometry 算法](../Leetcode%20Practices/system%20design/README.md#设计-Uber)
    - [限流算法 | Rate Limiter Algorithm](../Leetcode%20Practices/system%20design/README.md#设计-API-Rate-Limiter)
      - 固定窗口, 滑动窗口 | Fixed Window, Sliding Window ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/rate%20limiter%202/Solution.java)，固定窗口又称计数器法，即简单的 IncrBy 和 Expire TTL，虽然简单但有致命的临界问题)
      - 漏桶算法, 令牌桶算法 | Leaky Bucket, Token Bucket ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/rate%20limiter%203/Solution.java))
    - [退避算法 | Backoff Algorithm](../Leetcode%20Practices/object%20oriented%20design/design%20pattern/Retry.go)
    - [调度算法 | Scheduling](https://en.wikipedia.org/wiki/Scheduling_(computing)) (相关数学：[排队论 | Queueing Theory](https://en.wikipedia.org/wiki/Queueing_theory))
      - 非抢占式调度算法
        - FIFO (FCFS 先来先服务)、LIFO
        - [Generalized Processor Sharing Algorithm](https://en.wikipedia.org/wiki/Generalized_processor_sharing)、Round-Robin
        - 最短作业优先 | Shortest Job Next (SJF 可能出现处理饥饿，比如不断有短作业/进程到来，可能会导致长作业/进程长时间得不到处理)
        - 高响应比优先 | Highest Response Ratio Next (HRRN 综合考虑作业/进程的等待时间和要求服务的时间，所以不会出现处理饥饿，是介于 FCFS 与 SJF 之间的折中算法)
      - 抢占式调度算法
        - 最短剩余时间优先 | Shortest Remaining Time (SRTF 基于进程的剩余执行时间来确定下一个要执行的进程，SRTF 算法的工作原理如下：当一个进程到达系统时，系统会比较该进程的剩余执行时间与当前正在执行的进程的剩余执行时间。可能出现处理饥饿)
    - Loosy Counting 算法 (一种流式算法，用于在有限的内存空间内高效地估算数据流中元素的频率，允许一定的误差以节省存储资源)
    - [协同算法](./协同算法.md) ([处理协同编辑](../Leetcode%20Practices/system%20design/README.md#设计协同编辑系统)的算法。常用于作为实现文档协同的底层算法，支持多个用户同时编辑文档，不会因为用户并发修改导致冲突，而导致结果不一致甚至数据丢失的问题)
      - OT 协同算法 | Operational Transformation
      - CRDT 协同算法 | Conflict-Free Replicated Data Type
    - [四叉树算法, R 树算法 | QuadTree, RTree Algorithm](./QuadTree-RTree-算法.md)
    - 默克尔树算法 | Merkle Tree Algorithm ([Wiki](https://en.wikipedia.org/wiki/Merkle_tree)、[Code](./../Leetcode%20Practices/algorithms/easy/572%20Subtree%20of%20Another%20Tree.java))
    - Rete 匹配算法 | Rete Algorithm ([Wiki](https://en.wikipedia.org/wiki/Rete_algorithm)；Rete 算法通过构建高效的数据结构和利用条件之间的共享信息，避免了重复匹配和不必要的计算，从而实现了高效的规则匹配。由于其高效性和灵活性，被广泛应用于规则引擎、专家系统、数据挖掘等领域，是规则匹配的重要技术之一；时间复杂度通常为 `O(N)`)
    - 光线投射算法 | Ray Casting (基于图像序列的直接体绘制算法。从图像的每一个像素，沿固定方向发射一条光线，光线穿越整个图像序列，并在这个过程中，对图像序列进行采样获取颜色信息，同时依据光线吸收模型将颜色值进行累加，直至光线穿越整个图像序列，最后得到的颜色值就是渲染图像的颜色)
    - [垃圾回收算法 | Garbage Collection Algorithm](../Computer%20System%20Layer/JVM/README.md#垃圾回收) ([Ref](https://mp.weixin.qq.com/s/M8R4QPidlCrr6vix4JUWmg))
    - [共识机制/算法 (分布式选举问题) | Consensus Algorithm](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md) (或称选举算法，[etcd 实现](../Leetcode%20Practices/system%20design/example%20questions/Leader%20Election.md))
      - 崩溃容错协议 | CFT
        - Paxos、Raft ([Ref 1](https://cloud.tencent.com/developer/article/1816404)、[Ref 2](https://raft.github.io/))、[ZAB](https://houbb.github.io/2018/10/30/zab) (这 3 种协议有许多共同的内容，比如 Leader-Follower、[Quorum 仲裁机制](./Quorum算法.md)、状态机等等)
        - Bully 算法 ([Wiki](https://en.wikipedia.org/wiki/Bully_algorithm))
      - 拜占庭容错 | BFT ([Ref 1](https://www.bilibili.com/read/cv14498545)、[Ref 2](https://cloud.tencent.com/developer/news/580379)、[Ref 3](https://learnku.com/articles/56919))
        - PBFT、Hotstuff
    - [P2P 核心算法](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md)
      - BitTorrent 协议
      - DHT 的 Kademlia 协议
      - DHT 的 Chord 算法 ([Wiki](https://en.wikipedia.org/wiki/Chord_(peer-to-peer)))
      - [Gossip 协议/流行病协议](../Computer%20System%20Layer/数据库/Dynamo/README.md#Gossip-协议)
  - [人工智能, 机器学习, 数据挖掘 | Artificial Intelligence, Machine Learning, Data Mining](./机器学习.md) ([人工智能分类](./人工智能分类.jpeg)、[ML 算法时间复杂度](./ML-Algorithms-Time-Complexity.jpeg)、[训练与推断过程](./Training-and-Inference-workflow-diagram.png))
    - [决策树算法 | Decision Tree Algorithm](./机器学习.md#决策树) ([Ref 1](./decision-tree.png)、[Ref 2](https://www.ibm.com/cn-zh/topics/decision-trees))
      - [随机森林 | Random Forest](./机器学习.md#随机森林) ([Ref](https://www.nvidia.cn/glossary/data-science/random-forest/))
      - [梯度提升决策树 | Gradient Boosted Decision Trees](./机器学习.md#GBDT) ([Ref 1](https://github.com/NLP-LOVE/ML-NLP/blob/master/Machine%20Learning/3.2%20GBDT/3.2%20GBDT.md)、[Ref 2](https://developers.google.com/machine-learning/decision-forests/intro-to-gbdt))
        - [XGBoost](./机器学习.md#XGBoost) ([Ref](https://www.cnblogs.com/mantch/p/11164221.html))
    - 最近邻居法 | K-Nearest Neighbors Algorithm, KNN ([Wiki](https://zh.wikipedia.org/zh-hans/K-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95))
    - 朴素贝叶斯 | Naive Bayes
    - 支持向量机 | Support Vector Machine, SVM
    - 隐马尔可夫模型 | Hidden Markov Model, HMM ([Ref](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE)，用来描述一个含有隐含未知参数的[马尔可夫过程/随机状态转移](./Markovkate_01.svg.png)。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别)
      - 前向与后向算法 | Forward–Backward Algorithm
      - 维特比算法 | Viterbi Algorithm
    - [深度学习, 神经网络 | Deep Learning, Neural Networks](./机器学习.md#deep-learning) ([Ref](https://www.zhihu.com/question/314879954/answer/638380202))
      - [感知器 | Perceptron](./机器学习.md#single-neuron) ([Ref](https://www.youtube.com/watch?v=BS_CVhalVGw&list=PLxIHUhMHF8okwhq8poRuiHBChWjkVUHLL&index=2)；又称感知机、Neuron、Unit，该基本模型是神经网络的基础，是模拟了人工神经元的模型)
        - 卷积神经网络 | Convolutional Neural Network, CNN ([Wiki](https://zh.wikipedia.org/zh-hans/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C)、[Ref](https://www.nvidia.cn/glossary/data-science/convolutional-neural-network/)：用于处理网格数据，如图像、视频、音频等，进行特征提取和分类。结构由卷积层、池化层和全连接层组成，用于捕获局部特征和构建层次结构)
        - 循环神经网络 | Recurrent Neural Network, RNN (用于处理序列数据，如文本、语音、时间序列等，具有记忆性质。结构包括循环层 RNN、LSTM、GRU 等，用于处理序列中的时间依赖关系)
        - 长短期记忆 | Long Short-Term Memory, LSTM
        - 图神经网络 | Graph Neural Network, GNN (用于处理图数据，如社交网络、推荐系统、知识图谱、分子结构等，进行节点分类、链接预测等任务。结构包括图卷积层、图池化层和节点分类层，用于捕获图的结构和节点之间的关系)
        - 生成对抗网络 | Generative Adversarial Network, GAN (用于生成新的数据，例如图像、音频等。结构由生成器 Generator 和判别器 Discriminator 组成。生成器生成伪造数据，判别器评估生成器生成的数据与真实数据之间的相似性)
      - 多头模型 | Multi-Head Model ([Ref 1](https://debuggercafe.com/multi-head-deep-learning-models-for-multi-label-classification/)、[Ref 2](./multi_head_nn_diff_outputs.jpg)，在深度学习中，多头模型通常指的是在同一层或同一网络中使用多个独立的注意力头或输出头。每个头可以关注数据的不同方面或产生不同类型的输出)
      - [Transformer 模型, 大语言模型 (Large Language Model)](https://github.com/yihaoye/lyrics-gpt) (Related: [Wiki](https://en.wikipedia.org/wiki/Transformer_(machine_learning_model))、[注意力机制 1](https://en.wikipedia.org/wiki/Attention_(machine_learning))、[注意力机制 2](https://www.youtube.com/watch?v=nzqlFIcCSWQ)、[检索增强生成（RAG）](https://aws.amazon.com/cn/what-is/retrieval-augmented-generation/)、[GraphRAG](https://microsoft.github.io/graphrag/)、[提示工程](https://en.wikipedia.org/wiki/Prompt_engineering))
        - BERT
        - GPT ([build GPT from scratch](https://www.youtube.com/watch?v=kCc8FmEb1nY))
    - [多模态学习 | Multimodal Learning](./机器学习.md#多模态学习) ([Ref](https://zhuanlan.zhihu.com/p/53511144))
    - 关联规则学习 | Association Rule Learning ([Wiki](https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E8%A7%84%E5%88%99%E5%AD%A6%E4%B9%A0))
      - 先验算法 | Apriori algorithm ([Wiki](https://en.wikipedia.org/wiki/Apriori_algorithm)，寻找关联性的经典算法)
      - FP-Growth 算法 (以及相关的 Frequent Pattern Tree；[Ref](https://en.wikipedia.org/wiki/Frequent_pattern_discovery))
  - 并行算法 | Parallel Algorithm ([Wiki](https://en.wikipedia.org/wiki/Parallel_algorithm)、[Ref](https://blog.51cto.com/luweir/4873113?articleABtest=0)：并行算法尚在发展中，不及串行算法丰富。目前最常用的的方法是 PCAM 方法，即划分，通信，组合，映射。并行算法与串行算法最大的不同之处在于，并行算法不仅要考虑问题本身，而且还要考虑所使用的并行模型，网络连接等等)
    - 阿姆达尔定律 | Amdahl's Law ([Wiki](https://zh.wikipedia.org/wiki/%E9%98%BF%E5%A7%86%E8%BE%BE%E5%B0%94%E5%AE%9A%E5%BE%8B))
  - 图形学算法 | Computer Graphics Algorithm
    - Boids 模型 | Boids Model ([Wiki](https://en.wikipedia.org/wiki/Boids)，又称鸟群算法，用于模拟鸟类的群集行为以及相关的群体运动；[Ref](https://www.red3d.com/cwr/boids/))
  - [数学 | Maths](../Computer%20Science%20Maths/README.md) (以下分类不严格界限，互相可以有重叠)
    - 专项专题 | Special Topics
      - 排序网络 | Sorting Network ([Ref](http://www.matrix67.com/blog/archives/185))
      - [约瑟夫环/问题 | Josephus Problem](./约瑟夫环.md)
      - 欧拉图 | Euler Diagram ([Wiki](https://oi-wiki.org/graph/euler/))
      - [其他数学工具、操作与套路 | Other Math Tools](../Tool%20Sets/Math.java)
    - 数值分析 | Numerical Analysis ([Wiki](https://zh.wikipedia.org/wiki/%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90))
      - 矩阵运算 | Matrix Operations (时间复杂度 `O(N^3)`，[朴素的三重循环方法](../Leetcode%20Practices/algorithms/medium/311%20Sparse%20Matrix%20Multiplication.java)，对于每个输出矩阵中的元素，都需要进行 n 次乘法和 n−1 次加法操作；[矩阵乘法的本质、意义](https://juejin.cn/post/7350906935347560487))
        - 施特拉森算法 | Strassen Algorithm ([Ref](https://www.youtube.com/watch?v=0oJyNmEbS4w)，时间复杂度 `~O(n^(2.8))`；其他的优化算法还有 Coppersmith-Winograd，这些算法在特定条件下可以降低时间复杂度，但通常在实际应用中，由于其常数项较大，可能并不总是比朴素方法更快。因此，在实践中，朴素的方法仍然是常用的选择)
      - [快速傅立叶变换 | Fast Fourier Transform](./FFT.md) (时间复杂度 `O(N*logN)`，主要是用来加速多项式的乘法，另外还有[并行快速傅立叶变换](https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2)；本质是利用多项式 2 种表示法和复数单位根的数学特性，然后通过动态规划优化来实现计算复杂度降低的，具体可以是自上而下的递归也可以是自下而上的递推，与快速幂法同构类似)
      - [快速幂法 | Binary Exponentiation](../Tool%20Sets/Math.java)
        - [矩阵快速幂 | Matrix Exponentiation](./矩阵快速幂.md) ([Ref](https://hezhaojiang.github.io/post/2020/41da3a83/)：是一种基础算法，本身与动态规划没有关系，但常用于优化线性递推关系的计算，并且其思路比较固定，动态规划主要用于解决两类问题，一类是优化问题，求最优解，另一类是组合计数，求方案数。矩阵快速幂主要用在第二类，即组合计数，求方法数这类问题，可以将时间复杂度从 O(N) 降到 `O(logN)`)
      - [平方根倒数速算法 | Fast Inverse Square Root](./平方根倒数速算法.md)
      - [高斯消元法 | Gaussian Elimination](./高斯消元法.md) (时间复杂度 `O(N^3)`)
      - 高精度计算 | Arbitrary-Precision Arithmetic ([Wiki](https://oi-wiki.org/math/bignum/))
    - [组合 | Combinatorics](../Computer%20Science%20Maths/Combinatorics.md)
      - [鸽巢原理 | Pigeonhole Principle](./鸽巢原理.md)
      - 容斥原理 | Inclusion–Exclusion Principle ([Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/))
    - 数论 | Number Theory
      - [取模运算 | Modulo](./取模运算.md)
      - [埃氏筛法 | Eratosthenes Sieve](../Leetcode%20Practices/algorithms/medium/204%20Count%20Primes.java) (向前动态规划+排除法，时间复杂度 `O(N*loglogN)`)
        - [线性筛法 | Linear Sieve](../Leetcode%20Practices/algorithms/medium/204%20Count%20Primes.java) (埃氏筛法、欧拉筛法的优化，时间复杂度 `O(N)`)
      - 米勒-拉宾素性检验 | Miller–Rabin Primality Test ([Wiki](https://zh.wikipedia.org/wiki/%E7%B1%B3%E5%8B%92-%E6%8B%89%E5%AE%BE%E6%A3%80%E9%AA%8C)，一种素数判定法则，利用随机化算法判断一个数是合数还是可能是素数)
      - Pollard's Rho Algorithm ([Wiki](https://en.m.wikipedia.org/wiki/Pollard%27s_rho_algorithm))
      - 中国剩余定理 | Chinese Remainder Theorem ([Wiki](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86))
    - 概率论 | Probability Theory
      - 贝叶斯定理 | Bayes Theorem ([Wiki](https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86)；`P(A|B) = P(A)*P(B|A)/P(B)`)
      - 马尔可夫链 | Markov Chain ([Wiki](https://zh.wikipedia.org/wiki/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE))
    - 计算几何 | Computational Geometry
      - [扫描线 | Line Sweep](./扫描线.md)
      - [凸包 | Convex Hull](./凸包.md)
      - 三分搜索 | Ternary Search ([Ref](https://www.cnblogs.com/PJQOOO/p/4161891.html))
      - 向量计算 | Vector ([Ref](https://cp.wiwiho.me/vector/)，其实就是多维数据，一些工具如 MATLAB、NumPy 内置支持[阵列编程](https://zh.wikipedia.org/zh-hans/%E9%98%B5%E5%88%97%E7%BC%96%E7%A8%8B)，阵列编程原语 primitive 简明的表达了关于数据运算的宽泛想法，这种简明程度在特定情况下可能是戏剧性的：不难发现与阵列编程语言的一行程序相对应 Java 程序有时需要很多页代码)
    - 函数 | Function (离散或连续、周期性或非周期性、有界或无界) (注意：函数既满足算法的定义，也满足数据类型的定义，比如可以被处理、运算、传递、赋值等，例子如波可以被叠加。因此函数也可以被设计为自定义的类，在某些编程语言中，函数被视为第一类对象)
      - 波 (三角函数) | Wave (Trigonometric Function)
      - 分段函数 | Piecewise (比如阶跃函数)
      - 多项式 (包括常数函数、线性函数、开方函数等等) | Polynomial
      - 指数函数 ｜ Exponential Function
      - 反函数 (比如对数函数是指数函数的反函数) | Inverse Function
    - [博弈论 | Game Theory](./博弈论.md)
    - 最优化 | Mathematical Optimization ([Wiki](https://en.wikipedia.org/wiki/Mathematical_optimization)、[Ref](https://space.bilibili.com/97068901/channel/collectiondetail?sid=1387071)；最优化是应用数学的一个分支，是计算机与人工智能的一个重要研究领域：从很大程度上来说，[深度学习实际上是在解决大量复杂的优化问题](https://www.jiqizhixin.com/articles/071502)，神经网络仅仅是一个非常复杂的函数，包含数百万个参数，这些参数代表的是一个问题的数学解答，实质上，训练神经网络是在最小化一个损失函数，这个损失函数的值衡量了网络的性能在给定数据集上离完美还差多少)
      - 线性规划 | Linear Regression (特指目标函数和约束条件皆为线性的最优化问题，[图解](./Linear_programming_polytope.png))
        - 最小二乘法 | Least Squares Method ([Wiki](https://zh.wikipedia.org/wiki/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95)、[Ref](https://zhuanlan.zhihu.com/p/103918948))
      - 线搜索 | Line Search ([Wiki](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%90%9C%E7%B4%A2))
        - 梯度下降法 | Gradient Descent (梯度其实是高维导数的另一种称呼，[梯度法](https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E6%B3%95)是数值分析在最优化的应用之一)
        - 牛顿法 | Newton's Method (数值分析在最优化的应用之一)
      - Adam 优化算法 ([Ref](https://zhuanlan.zhihu.com/p/32626442))
      - 凸函数/凸优化 | Convex Function/Optimization ([Wiki 1](https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%87%BD%E6%95%B0)、[Wiki 2](https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%84%AA%E5%8C%96)、[非凸优化](https://zhuanlan.zhihu.com/p/70127314))
  - 其他常见优化思想、技巧 | Common Tricks
    - [剪枝 | Pruning](./剪枝.md)
    - 预处理 (打表) | Precompute (Hard Coding) ([Ref](https://www.cnblogs.com/hxtblogs/p/7654635.html))
    - [懒更新 | Lazy Update](./懒更新.md)
    - [状态压缩 | State Compression](../Tool%20Sets/StateCompression.java)
    - [稀疏压缩/坐标离散化 | Sparse/Coordinate Compression](./坐标离散化.md)
    - [集合的整数表示 (位集、位向量) | Bit Set](./集合的整数表示.md)
    - [比较优化，减少比较次数 (算法导论 9.1)](./../Leetcode%20Practices/algorithms/easy/1491%20Average%20Salary%20Excluding%20the%20Minimum%20and%20Maximum%20Salary.java)


</br>

以上部分参考自链接：[Ref 1](https://oi-wiki.org/basic/)、[Ref 2](https://www.acoier.com/tags/)、[Ref 3](http://www.matrix67.com/blog/)、[Ref 4](https://writings.sh/)、[Ref 5](https://github.com/halfrost/LeetCode-Go#algorithm)、[Ref 6](https://cp-algorithms.com/navigation.html)。  
