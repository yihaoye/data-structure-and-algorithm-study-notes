## 算法与理论 | Algorithms and Theory

This personal Blog contains explanation and **Java library/template implementation of some Advanced Algorithms**. For Advanced Data Structure library implementation, please check [here](../Common%20Data%20Structure%20and%20Data%20Type/README.md).  
  
- 理论与概念 | Theory and Concept ([Wiki](https://oi-wiki.org/misc/cc-basic/))
  - [时空复杂度 | Time and Space Complexity](./时空复杂度.md)
  - [算法分析初步 | Algorithm Analysis](../算法竞赛入门经典/README.md)
    - 渐进分析 | Asymptotic Analysis
    - 平摊分析 | Amortized Analysis
    - 随机算法分析 | Random Algorithm Analysis (涉及到概率和期望值的计算)
  - [多项式时间 | Polynomial Time](./多项式时间.md)
  - [搜索 | Search](./搜索.md)
  - [在线/离线算法 | Online/Offline Algorithm](./在线离线算法.md)
  - 离散与连续 (数据集) | Discrete and Continuous
- 算法分析工具 | Algorithm Analysis Tools
  - [递归树 | Recursion Tree](./递归树.md)
  - 循环不变量 | Loop Invariants
- 算法 | Algorithms
  - 基础与思维 | Foundation and Thought
    - [排序 (常用排序算法) | Sorting](./Common%20Sorts/README.md)
    - [枚举/穷举 | Enumerate](./枚举(穷举)算法.md)
    - [模拟 | Simulation](./模拟算法.md)
    - [递归, 迭代 | Recursion, Iteration](./递归与迭代.md)
    - [分治法 | Divide-and-Conquer](./分治法.md) (通常被认为一种方案思路或算法范型而非具体算法，时间复杂度不固定，比如快速幂的开方分解则为 `O(logN)`，而更通常的线性分解则为 `O(N)` 或 `O(N*f(N))` 或 `O(N*logN)` 比如归并排序，其他分解情况下亦有可能是其他大 O) ([分治法与二分算法的区别](./分治法.md#分治法-vs-二分算法))
    - 推理 | Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%8E%A8%E7%90%86))
      - 演绎法 | Deductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%BC%94%E7%BB%8E%E6%8E%A8%E7%90%86)；Dynamic Programming 或任意 Top-Down、Bottom-Up 的算法都基于此法)
      - 溯因法 | Abductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E6%BA%AF%E5%9B%A0%E6%8E%A8%E7%90%86)；常用于 debug 和改善性能)
      - 归纳法 | Inductive Reasoning ([Wiki](https://zh.wikipedia.org/zh-hans/%E5%BD%92%E7%BA%B3%E6%8E%A8%E7%90%86)；可用于基于测试数据的输入输出案例进行目标算法逻辑的先期猜测、过滤)
  - 中阶 | Intermediate
    - [二分搜索/二分算法 | Binary Search](./二分搜索.md) (时间复杂度 `O(logN)`)
    - [双指针法, 滑动窗口算法 | Two Pointer, Sliding Window](./双指针法与滑动窗口算法.md)
    - [深度优先, 广度优先, 树图遍历 | Depth First Search, Breadth First Search](./树图遍历.md)
      - [回溯法 | Backtracking](./NQueen.java)
      - 双向搜索/中途相遇 | Bidirectional-Search/Meet-in-the-Middle-Search ([Wiki](https://oi-wiki.org/search/bidirectional/))
    - [贪心算法 | Greedy Algorithm](./贪婪算法.md)
      - [耐心排序 | Patience Sorting](./耐心排序.md)
      - 摩尔投票 | Boyer–Moore Majority Vote Algorithm ([Wiki](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%95%B0%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95))
    - [拓扑排序 | Topological Sorting](./拓扑排序.md) (时间复杂度 `O(N)`)
    - [单调栈 (包括单调队列) | Monotone Stack](./单调栈.md) (时间复杂度 `O(N)`)
    - [自定义哈希/指纹 | Customized HashCode/FingerPrint](./自定义哈希指纹.md) (时间复杂度 `O(N)`)
      - [滚动哈希 | Rolling Hash (Rabin-Karp)](./滚动哈希.md) (时间复杂度 `O(N+M)`)
    - [快速选择 (霍尔选择算法) | Quickselect (Randomized Selection)](./快速选择.md)
    - [位运算 | Bitwise Operation](./位运算.md)
    - [洗牌算法 | Knuth-Shuffle](./../Leetcode%20Practices/algorithms/medium/384%20Shuffle%20an%20Array.java)
  - 进阶 | Advanced
    - [动态规划, 状态机, 规则引擎 | Dynamic Programming, State Machine, Rule Engine](./动态规划与状态机.md) (动态规划本质上属于分治法的应用)
      - [前缀和, 差分, 树状数组, 线段树 | Prefix Sum, Difference, Binary Indexed Tree, Segment Tree](./前缀和与差分.md)
      - [记忆化搜索 | Memory Search](./记忆化搜索.md)
      - [倍增法 | Binary Lifting](./倍增法.md) (时间复杂度 - 预处理 `O(N*logN)`，之后查询 `O(logN)`) ([倍增法与二分法的区别](./倍增法.md#二分-vs-倍增))
      - [弗洛伊德算法 | Floyd-Warshall Algorithm](./弗洛伊德算法.md) (时间复杂度 `O(N^3)`)
      - [Kadane 算法 | Kadane's Algorithm](./Kadane算法.md) (时间复杂度 `O(N)`)
      - 词法分析 | Lexical Analysis ([Wiki](https://zh.wikipedia.org/wiki/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)、[Simple Example: JSON Parser](../Leetcode%20Practices/object%20oriented%20design/other%20practices/json%20parser/README.md))
    - [KMP 算法 | Knuth–Morris–Pratt Algorithm](./KMP算法.md) (时间复杂度 `O(N+M)`)
    - [AC 自动机 | Aho–Corasick Algorithm](./AC自动机.md)
    - 马拉车算法 | Manacher Algorithm
    - [并查集联合查找算法 | Disjoint-Set Union-Find Algorithm, DSU](./并查集与联合查找算法.md) (时间复杂度 `O(a(N))` - a(N) 为反阿克曼函数，对于大部分 N，a(N) 均小于 5，所以并查集的时间复杂度也可视为 `O(1)`)
    - [图匹配 | Graph Match](./图匹配.md)
      - 染色法 | Coloring Method
      - [匈牙利算法 | Hungarian Algorithm](./匈牙利算法.md) (时间复杂度 `O(N^3)`)
    - [最小生成树相关算法 | Minimum Spanning Tree Algorithms](./../Common%20Data%20Structure%20and%20Data%20Type/Data%20Structure%20Implementation/MinimumSpanningTree/README.md)
    - [网络流相关算法 | Flow Network Algorithms](./网络流.md)
      - [增广路 | Augmenting Path](../Common%20Algorithm%20and%20Theory/图匹配.md#增广路定理-Berge's-lemma)
    - [迪杰斯特拉算法 | Dijkstra Algorithm](./Dijkstra算法.md) (时间复杂度 `O(V+E*logV)` - 仅计算了指定的一个起点到其他各点)
    - 贝尔曼-福特算法 | Bellman-Ford Algorithm
    - 启发式算法/搜索 | Heuristic Algorithm/Search (启发式搜索通常不讨论时空复杂度)
      - [A&ast; 搜索算法 | A&ast; Search Algorithm](./A*搜索算法.md) (基于 Dijkstra 算法添加了启发式函数，最坏时间复杂度：`O(V+E*logV)`)
        - IDA&ast; 算法 | IDA&ast; Algorithm
      - 禁忌搜索 | Tabu Search
      - 爬山算法 | Hill Climbing
      - [随机数生成算法 | Random Number Generator](./随机数生成算法.md)
      - 随机化算法/搜索 | Random Algorithm/Search (随机化算法高效的原因是它跳过不必要的枝节、搜索空间。另外，有些随机化算法如随机森林可以容易地并行化，因为它们的操作不一定依赖于前一步骤的结果，这使得它们在多核或分布式计算环境中更高效)
        - 蒙特卡洛方法 | Monte Carlo Method ([Ref](https://renns.top/post/59/)，采样越多，越近似最优解)
          - [模拟退火 | Simulated Annealing](./模拟退火.md)
          - [遗传算法 | Genetic Algorithm](./遗传算法.md)
          - [粒子群优化算法 | Particle Swarm Optimization](./粒子群优化算法.md)
          - 蒙特卡洛树搜索 | Monte Carlo Tree Search (用于搜索树型结构的算法，广泛应用于博弈和决策问题，如 AlphaGo)
        - 拉斯维加斯方法 | Las Vegas Method (采样越多，越可能找到最优解)
  - 系统级 | System Level
    - [字典树算法 | Trie Algorithm](./../Common%20Data%20Structure%20and%20Data%20Type/Data%20Structure%20Implementation/Trie/README.md)
    - [映射-归约 | MapReduce](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md)
    - 多路归并 | K-Way Merge ([Wiki](https://en.wikipedia.org/wiki/K-way_merge_algorithm)、[Code](../Leetcode%20Practices/algorithms/hard/23%20Merge%20k%20Sorted%20Lists.java))
    - 环形缓冲器及其算法 | Ring Buffer ([Wiki](https://zh.wikipedia.org/wiki/%E7%92%B0%E5%BD%A2%E7%B7%A9%E8%A1%9D%E5%8D%80)；注意，可以用一个最长的环实现多环复用，用一个变量或指针记录当前的长环尾部，若想获取短环则只需从长环尾部往前回溯一次短环长度再开始遍历即可)
    - [分块/分桶法 | Range Block/Bucketing](./分桶法.md) (若为平方分割，则时间复杂度 `O(√N)`，通常在线/离线均可使用)
      - 莫队算法 | Mo Algorithm ([Wiki](https://oi-wiki.org/misc/mo-algo/)，通常用于离线算法)
    - [蓄水池抽样算法 | Reservoir Sampling](./蓄水池抽样算法.md) (时间复杂度为 `O(N)` 且为一次遍历即可，空间复杂度 `O(m)` m 为从流中随机选出 m 个，因为 m 通常为有限的常数，所以空间复杂度可以认为是 `O(1)`)
    - [霍夫曼压缩算法 | Huffman Coding/Compression](./霍夫曼压缩算法.md)
    - [布隆过滤器及其算法 | Bloom Filter](./布隆过滤器及其算法.md)
    - [Count-Min Sketch 算法](./Count-Min-Sketch.md)
    - 最小哈希 | MinHash ([Wiki](https://en.wikipedia.org/wiki/MinHash))
    - [HyperLogLog 算法](./HyperLogLog.md)
    - [雪花算法 | Snowflake ID](./雪花算法.md)
    - 一致性哈希 | Consistent Hashing ([Ref](https://dgryski.medium.com/consistent-hashing-algorithmic-tradeoffs-ef6b8e2fcae8)) (数据操作时间复杂度为 `O(logN)`，节点增删时间复杂度为 `~O(N/M)` 其中 M 为实际节点数)
      - [环形哈希 (虚拟节点) | Ring Hashing](./../Leetcode%20Practices/system%20design/一致性哈希.md) ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/consistent%20hash/README.md))
      - 跳跃哈希 | Jump Hashing ([Ref 1](https://arxiv.org/pdf/1406.2294.pdf)、[Ref 2](https://writings.sh/post/consistent-hashing-algorithms-part-3-jump-consistent-hash))
      - Multi-Probe Consistent Hashing
      - Rendezvous Hashing ([Wiki](https://en.m.wikipedia.org/wiki/Rendezvous_hashing))
      - Maglev Hashing
    - [反向索引 | Inverted Index]((../Leetcode%20Practices/system%20design/README.md#设计搜索引擎-Twitter-Search)) ([Code](../Leetcode%20Practices/object%20oriented%20design/other%20practices/inverted%20index/InvertedIndex.java))
    - Frugal Streaming 算法
    - [Geohash 算法, S2 Geometry 算法](../Leetcode%20Practices/system%20design/README.md#设计-Uber)
    - [漏桶算法, 令牌桶算法 | Leaky Bucket, Token Bucket](../Leetcode%20Practices/system%20design/README.md#设计-API-Rate-Limiter)
    - Loosy Counting 算法
    - [OT 算法 | Operational Transformation](../Leetcode%20Practices/system%20design/README.md#设计协同编辑系统)
    - [四叉树算法, R 树算法 | QuadTree, RTree Algorithm](./QuadTree-RTree-算法.md)
    - 默克尔树算法 | Merkle Tree Algorithm ([Wiki](https://en.wikipedia.org/wiki/Merkle_tree)、[Code](./../Leetcode%20Practices/algorithms/easy/572%20Subtree%20of%20Another%20Tree.java))
    - 光线投射算法 | Ray Casting
    - Rsync 算法 ([Wiki](https://zh.wikipedia.org/zh-cn/Rsync#%E6%BC%94%E7%AE%97%E6%B3%95))
    - [共识机制/算法 (分布式选举问题) | Consensus Algorithm](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md) ([etcd 实现](../Leetcode%20Practices/system%20design/example%20questions/Leader%20Election.md))
      - 崩溃容错协议 | CFT
        - Paxos、Raft ([Ref 1](https://cloud.tencent.com/developer/article/1816404)、[Ref 2](https://raft.github.io/))、[ZAB](https://houbb.github.io/2018/10/30/zab) (这 3 种协议有许多共同的内容，比如 Leader-Follower、[Quorum 仲裁机制](./Quorum算法.md)、状态机等等)
      - 拜占庭容错 | BFT ([Ref 1](https://www.bilibili.com/read/cv14498545)、[Ref 2](https://cloud.tencent.com/developer/news/580379)、[Ref 3](https://learnku.com/articles/56919))
        - PBFT、Hotstuff
    - [P2P 核心算法](../Leetcode%20Practices/system%20design/System%20Design%20Fundamentals.md)
      - BitTorrent 协议
      - DHT 的 Kademlia 协议
      - DHT 的 Chord 算法 ([Wiki](https://en.wikipedia.org/wiki/Chord_(peer-to-peer)))
      - [Gossip 协议/流行病协议](../Computer%20System%20Layer/数据库/Dynamo/README.md#Gossip-协议)
  - [人工智能, 机器学习 | Artificial Intelligence, Machine Learning](./机器学习.md)
    - [决策树算法 | Decision Tree Algorithm](./机器学习.md#决策树) ([Ref](https://www.ibm.com/cn-zh/topics/decision-trees))
      - [随机森林 | Random Forest](./机器学习.md#随机森林) ([Ref](https://www.nvidia.cn/glossary/data-science/random-forest/))
    - 朴素贝叶斯 | Naive Bayes
    - 支持向量机 | Support Vector Machine, SVM
    - 隐马尔可夫模型 | Hidden Markov Model, HMM
      - 前向与后向算法 | Forward–Backward Algorithm
      - 维特比算法 | Viterbi Algorithm
    - [深度学习, 神经网络 | Deep Learning, Neural Networks](./机器学习.md#deep-learning) ([Ref](https://www.zhihu.com/question/314879954/answer/638380202))
      - [感知器 | Perceptron](./机器学习.md#single-neuron) ([Ref](https://www.youtube.com/watch?v=BS_CVhalVGw&list=PLxIHUhMHF8okwhq8poRuiHBChWjkVUHLL&index=2)；又称感知机、Neuron、Unit，该基本模型是神经网络的基础，是模拟了人工神经元的模型)
      - 卷积神经网络 | Convolutional Neural Network, CNN (用于处理网格数据，如图像、视频、音频等，进行特征提取和分类。结构由卷积层、池化层和全连接层组成，用于捕获局部特征和构建层次结构)
      - 循环神经网络 | Recurrent Neural Network, RNN (用于处理序列数据，如文本、语音、时间序列等，具有记忆性质。结构包括循环层 RNN、LSTM、GRU 等，用于处理序列中的时间依赖关系)
        - 长短期记忆 | Long Short-Term Memory, LSTM
      - 图神经网络 | Graph Neural Network, GNN (用于处理图数据，如社交网络、推荐系统、知识图谱、分子结构等，进行节点分类、链接预测等任务。结构包括图卷积层、图池化层和节点分类层，用于捕获图的结构和节点之间的关系)
      - 生成对抗网络 | Generative Adversarial Network, GAN (用于生成新的数据，例如图像、音频等。结构由生成器 Generator 和判别器 Discriminator 组成。生成器生成伪造数据，判别器评估生成器生成的数据与真实数据之间的相似性)
      - [Transformer 模型, 大语言模型 (Large Language Model)](https://github.com/yihaoye/lyrics-gpt) (Related: [Wiki](https://en.wikipedia.org/wiki/Transformer_(machine_learning_model))、[build GPT from scratch](https://www.youtube.com/watch?v=kCc8FmEb1nY)、[注意力机制 1](https://en.wikipedia.org/wiki/Attention_(machine_learning))、[注意力机制 2](https://www.youtube.com/watch?v=nzqlFIcCSWQ))
    - 多模态学习 | Multimodal Learning ([Ref](https://zhuanlan.zhihu.com/p/53511144))
  - 并行算法 | Parallel Algorithm ([Wiki](https://en.wikipedia.org/wiki/Parallel_algorithm)、[Ref](https://blog.51cto.com/luweir/4873113?articleABtest=0)：并行算法尚在发展中，不及串行算法丰富。目前最常用的的方法是 PCAM 方法，即划分，通信，组合，映射。并行算法与串行算法最大的不同之处在于，并行算法不仅要考虑问题本身，而且还要考虑所使用的并行模型，网络连接等等)
  - [数学 | Maths](../Computer%20Science%20Maths/README.md)
    - 专项专题 | Special Topics
      - 排序网络 | Sorting Network ([Ref](http://www.matrix67.com/blog/archives/185))
      - 矩阵运算 | Matrix Operations
        - 施特拉森算法 | Strassen Algorithm ([Ref](https://www.youtube.com/watch?v=0oJyNmEbS4w)；时间复杂度 `~O(n^(2.8))`)
      - 线性规划 | Linear Regression
      - [快速傅立叶变换 | Fast Fourier Transform](./FFT.md) (时间复杂度 `O(N*logN)`)
      - [鸽巢原理 | Pigeonhole Principle](./鸽巢原理.md)
      - 容斥原理 | Inclusion–Exclusion Principle ([Wiki](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/))
      - [取模运算 | Modulo](./取模运算.md)
      - [快速幂法 | Binary Exponentiation](../Tool%20Sets/Math.java)
      - [高斯消元法 | Gaussian Elimination](./高斯消元法.md)
      - 中国剩余定理 | Chinese Remainder Theorem ([Wiki](https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86))
      - 高精度计算 | Arbitrary-Precision Arithmetic ([Wiki](https://oi-wiki.org/math/bignum/))
      - [约瑟夫环/问题 | Josephus Problem](./约瑟夫环.md)
      - 欧拉图 | Euler Diagram ([Wiki](https://oi-wiki.org/graph/euler/))
      - 计算几何 | Computational Geometry
        - [扫描线 | Line Sweep](./扫描线.md)
        - [凸包 | Convex Hull](./凸包.md)
        - 三分搜索 | Ternary Search ([Ref](https://www.cnblogs.com/PJQOOO/p/4161891.html))
        - 向量计算 | Vector ([Ref](https://cp.wiwiho.me/vector/))
      - 函数 (离散或连续、周期性或非周期性、有界或无界) | Function (注意：函数既满足算法的定义，也满足数据类型的定义，比如可以被处理、运算、传递、赋值等，例子如波可以被叠加。因此函数也可以被设计为自定义的类，在某些编程语言中，函数被视为第一类对象)
        - 波 (三角函数) | Wave (Trigonometric Function)
        - 分段函数 | Piecewise
        - 多项式 (包括常数函数、线性函数、开方函数等等) | Polynomial
        - 指数函数 ｜ Exponential Function
        - 反函数 (比如对数函数是指数函数的反函数) | Inverse Function
      - [其他数学工具、操作与套路 | Other Math Tools](../Tool%20Sets/Math.java)
    - [博弈论 | Game Theory](./博弈论.md)
    - 最优化 | Mathematical Optimization ([Wiki](https://en.wikipedia.org/wiki/Mathematical_optimization)、[Ref](https://space.bilibili.com/97068901/channel/collectiondetail?sid=1387071)；最优化是应用数学的一个分支，是计算机与人工智能的一个重要研究领域：从很大程度上来说，[深度学习实际上是在解决大量复杂的优化问题](https://www.jiqizhixin.com/articles/071502)，神经网络仅仅是一个非常复杂的函数，包含数百万个参数，这些参数代表的是一个问题的数学解答，实质上，训练神经网络是在最小化一个损失函数，这个损失函数的值衡量了网络的性能在给定数据集上离完美还差多少)
      - 线搜索 | Line Search
      - 梯度下降法 | Gradient Descent (梯度其实是高维导数的另一种称呼)
      - 牛顿法 | Newton's Method
      - Adam 优化算法 ([Ref](https://zhuanlan.zhihu.com/p/32626442))
      - 凸函数/凸优化 | Convex Function/Optimization ([Wiki 1](https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%87%BD%E6%95%B0)、[Wiki 2](https://zh.wikipedia.org/zh-hans/%E5%87%B8%E5%84%AA%E5%8C%96)、[非凸优化](https://zhuanlan.zhihu.com/p/70127314))
  - 其他常见优化思想、技巧 | Common Tricks
    - [剪枝 | Pruning](./剪枝.md)
    - 预处理 (打表) | Precompute (Hard Coding) ([Ref](https://www.cnblogs.com/hxtblogs/p/7654635.html))
    - [懒更新 | Lazy Update](./懒更新.md)
    - [状态压缩 | State Compression](../Tool%20Sets/StateCompression.java)
    - [稀疏压缩/坐标离散化 | Sparse/Coordinate Compression](./坐标离散化.md)
    - [集合的整数表示 (位集、位向量) | Bit Set](./集合的整数表示.md)
    - [比较优化，减少比较次数 (算法导论 9.1)](./../Leetcode%20Practices/algorithms/easy/1491%20Average%20Salary%20Excluding%20the%20Minimum%20and%20Maximum%20Salary.java)


</br>

以上部分参考自链接：[Ref 1](https://oi-wiki.org/basic/)、[Ref 2](https://www.acoier.com/tags/)、[Ref 3](http://www.matrix67.com/blog/)、[Ref 4](https://writings.sh/)、[Ref 5](https://github.com/halfrost/LeetCode-Go#algorithm)。  
