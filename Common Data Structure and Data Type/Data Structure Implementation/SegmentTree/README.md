# 线段树

参考：  
https://www.youtube.com/watch?v=rYBtViWXYeI  
https://zxi.mytechroad.com/blog/sp/segment-tree-sp14/  
https://zhuanlan.zhihu.com/p/106118909  
https://zhuanlan.zhihu.com/p/174810030  
https://zhuanlan.zhihu.com/p/34150142  
https://cp-algorithms.com/data_structures/segment_tree.html  
https://oi-wiki.org/ds/seg/  
  
## 原理与实现
线段树是一颗近似的完全二叉树，每个节点代表一个区间，节点的权值是该区间的求值（最值、计算值等等）。根节点是整个区间。每个节点的左孩子是该节点所代表的的区间的左半部分，右孩子是右半部分。为方便起见，如果区间长度为奇数，则左孩子为较长的半部分。通过线段树，可以用 O(logn) 的时间复杂度完成查询和更新操作。当然，预处理的时间复杂度是 O(n)。  
  
### 线段树的单点更新
单点修改，需要找到该叶子节点，然后对其进行更新，叶子节点更新之后，它的父节点也需要更新，父节点仍然为左右子树中较小的那个。从根节点出发。找到当前区间的中点，判断中点和待更新的节点的大小，以此来判断是在当前节点的左子树还是右子树。然后递归更新，如果找到了叶子节点，说明当前的这个叶子节点就是需要改的点，直接对其更新即可。最后不要忘了更新父节点的权值。  
  
![](./Segment%20Tree%201.png)  
![](./Segment%20Tree%202.png)  
![](./Segment%20Tree%203.png)  
![](./Segment%20Tree%204.png)  
  
与数状数组类似但是比数状数组直观且强大  
[线段树 Java 实现代码](./SegmentTree.java)  
  
### 线段树的区间更新
上述是未优化区间更新操作的线段树实现，思考一下：区间修改，假设修改的值有 m 个，直接想到的一个办法就是执行 m 次单点更新，即朴素的想法是用递归的方式一层层修改（类似于线段树的建立），但这样的时间复杂度比较高为 O(mlogn) 这不是所想看到的，假设所有的元素都更新，那么还不如直接重新构建整颗线段树。所以在这里用了一个优化的思想，就是延迟更新，延迟更新就是，更新的时候，不进行操作，只是标记一下这个点需要更新，在真正使用的时候才去更新，这在进行一些数据库的业务的时候，也是很重要的一个思想。这个标记就是懒标记（或延迟标记），懒标记是线段树的精髓所在，使用懒标记后（后面示例代码里的成员变量 mark），对于那些正好是线段树节点的区间，不继续递归下去，而是打上一个标记并更新节点值，将来要用到它的子区间的时候，再向下传递。在进行区间修改的时候，分 3 种情况：  
1. 当前区间（代表区间的节点）与目标区间没有交集，这时直接结束递归。
2. 当前区间（代表区间的节点）被包括在目标区间里，这时可以更新当前区间节点，别忘了乘上区间长度（比如该区间节点都加上 c，区间有 m 个节点，则该区间节点 val += c*m -- 这个例子的求值逻辑是求和如果线段树是其他求值逻辑则换成其他计算公式），然后打上懒标记（mark += d，这个标记表示`该区间上每一个点都要加上 d`，因为原来可能存在标记，所以是 += 而不是 =。叶子节点可以不打标记，因为不会再向下传递了）
3. 当前区间（代表区间的节点）与目标区间相交，但不被完全包含于其中，这时把当前区间一分为二，进行以下处理：
    1. 这里有个问题，当多次区间修改，且修改之后没有查询且两次修改的区间有交集但不被完全包含时，会造成的父子节点 mark 变量重叠错误。所以必须保证每时每刻线段树内被标记（懒标记不为零）的节点们都只能组成一个或多个无重叠的区间，这样就需要添加一个操作，如果当前区间（代表区间的节点）存在懒标记，要先把懒标记传递给子节点（如果求值逻辑是求和，则注意也是 +=，因为子节点原来可能存在懒标记不为零，这些子节点的值也需要相应的更新 += 传递的懒标记值乘以子节点区间长度）（这个过程并不是递归的，只往下传递一层，所以叫懒标记，以后要用再才继续传递），然后清零本节点的标记。
    2. 传递完标记后，再递归地去处理当前区间（代表区间的节点）的左右两个子节点（即递归重复区间修改的 3 种情况直到每次递归遇到 1、2 情况而停止）。
  
**优化后线段树的区间查询**  
另外区间查询时也与区间修改完全类似分 3 种情况  
遇到情况 3 时，如果当前区间（代表区间的节点）存在懒标记，也要先把懒标记传递给子节点，完全相同的 pushDown 方法，然后进行同样的递归。  
  
```java
private void pushDown(int index) { // 把当前节点的标志值传给子节点
    Node node = nodes[index]; // 获取该下标的节点
    nodes[2 * index].addMark(node.mark); // 更新左子树的标志
    nodes[2 * index + 1].addMark(node.mark); // 更新右子树的标志
    nodes[2 * index].data += node.mark * (nodes[2 * index].end - nodes[2 * index].start + 1); // 左子树的值加上标志值乘以子节点区间长度
    nodes[2 * index + 1].data += node.mark * (nodes[2 * index + 1].end - nodes[2 * index + 1].start + 1); // 右子树的值加上标志值乘以子节点区间长度
    node.clearMark(); // 清除当前节点的标志值
}
```  
  
## 例题
[Leetcode 307](./../../../Leetcode%20Practices/algorithms/medium/307%20Range%20Sum%20Query%20-%20Mutable.java)  
