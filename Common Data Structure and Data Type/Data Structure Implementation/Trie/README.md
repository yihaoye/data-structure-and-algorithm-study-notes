以下转自: https://oi-wiki.org/string/trie/  
  
Trie树，又称字典树、前缀树、单词查找树、键树，是一种多叉树形结构，是一种哈希树的变种。顾名思义，就是一个像字典一样的树。  
  
简介图：  
  
![](Trie.png)  
  
可以发现，这棵字典树用边来代表字母，而从根结点到树上某一结点的路径就代表了一个字符串。举个例子，1 -> 4 -> 8 -> 12 表示的就是字符串 caa 。  
  
Trie 的结构非常好懂，用 next(u,c) 表示结点 u 的 c 字符指向的下一个结点，或着说是结点 u 代表的字符串后面添加一个字符 c 形成的字符串的结点。（ c 的取值范围和字符集大小有关，不一定是 0 - 26 。）  
  
有时需要标记插入进 Trie 的是哪些字符串，每次插入完成时在这个字符串所代表的节点处打上标记即可。  
  
时间复杂度：O(L) - 无论插入还是搜索，空间复杂度：O(prefixes)，L 为插入单词的长度。  
  
Trie 的核心思想是空间换时间，利用字符串的公共前缀来降低查询时间的开销以达到提高效率的目的。  
假设字符的种数有 M 个 (字符集元素个数)，有若干个长度为 L 的字符串构成了一个 Trie 树，则每个节点的出度为 M（即每个节点的可能子节点数量为 M），Trie 树的高度为 L。很明显使用了大量的空间来存储字符，此时 Trie 树的最坏空间复杂度为 O(M^L)。也正由于每个节点的出度为 M，所以算法能够沿着树的一个个分支高效的向下逐个字符的查询，而不是遍历所有的字符串来查询，此时 Trie 树的最坏时间复杂度为 O(L)。这正是空间换时间的体现，也是利用公共前缀降低查询时间开销的体现。[参考](https://blog.csdn.net/u010599509/article/details/54410619)  
  
[C++ Code](Trie.cpp)  
[Java Code](../../../Leetcode%20Practices/algorithms/medium/208%20Implement%20Trie%20(Prefix%20Tree).java)  
  
### 其他例题
* [Leetcode Q211](./../../../Leetcode%20Practices/algorithms/medium/211%20Design%20Add%20and%20Search%20Words%20Data%20Structure.java)  
  
## 应用
检索字符串  
字典树最基础的应用——查找一个字符串是否在“字典”中出现过。  
  
AC 自动机  
Trie 是 AC 自动机 的一部分。  
  
霍夫曼压缩算法  
  
异或相关(待看)  
将数的二进制表示看做一个字符串，就可以建出字符集为 {0,1} 的 Trie 树。  
  
可持久化字典树(待看)  
