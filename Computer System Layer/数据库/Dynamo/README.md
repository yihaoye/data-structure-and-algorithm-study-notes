# 目标
设计一个高度可用（即可靠）、高度可扩展、完全去中心化的分布式键值存储。

什么是 Dynamo？
Dynamo 是亚马逊为其内部使用而开发的一种高可用键值存储。许多亚马逊服务，如购物车、畅销书列表、销售排名、产品目录等，只需要对数据进行主键访问。一个多表的关系型数据库系统对于这类服务来说是一种过度，同时也会限制可扩展性和可用性。Dynamo 提供了一个灵活的设计，让应用程序选择他们想要的可用性和一致性水平。

# 背景
Dynamo - 不要与 DynamoDB 混淆，后者的设计灵感来自于 Dynamo - 是一个分布式键值存储系统，在大规模的情况下提供 "永远在线"（或高度可用）的体验。在 CAP 定理的术语中，Dynamo 属于 AP 系统的范畴（即可用和分区容忍），并且是以牺牲强一致性为代价来设计高可用性和分区容忍。将 Dynamo 设计成一个高可用系统的主要动机是观察到系统的可用性与所服务的客户数量直接相关。因此，主要目标是系统即使不完善，也应该对客户可用，因为它能带来更多的客户满意度。另一方面，不一致的问题可以在后台解决，而且大多数时候客户不会注意到它们。从这个核心原则出发，Dynamo 积极地对可用性进行了优化。

Dynamo 的设计具有很大的影响力，因为它启发了许多NoSQL数据库，如 Cassandra、Riak 和 Voldemort -- 更不用说亚马逊自己的 DynamoDB。

# 设计目标
如上所述，Dynamo 的主要目标是高度可用。下面是其其他设计目标的总结。

可扩展性。该系统应该是高度可扩展的。我们应该能够把一台机器扔进系统中，看到相应的改进。  
分散的。为了避免单点故障和性能瓶颈，不应该有任何中央/领导的过程。  
最终一致的。数据可以被乐观地复制，成为最终一致的。这意味着，与其为确保整个系统的数据正确性而产生写入时间成本（即强一致性），不如在其他时间（例如，在读取过程中）解决不一致的问题。最终的一致性被用来实现高可用性。  

![](./Dynamo%20High%20Level.png)  
分布式键值存储的高层次视图  

# Dynamo 的使用案例
默认情况下，Dynamo 是一个最终一致的数据库。因此，任何不关心强一致性的应用都可以利用 Dynamo。尽管 Dynamo 可以支持强一致性，但它会对性能产生影响。因此，如果强一致性是一个应用程序的要求，那么 Dynamo 可能不是一个好的选择。  

Dynamo 在亚马逊被用来管理那些对可靠性要求非常高的服务，并且需要严格控制可用性、一致性、成本效益和性能之间的权衡。亚马逊的平台有非常多样化的应用，有不同的存储要求。许多应用选择 Dynamo 是因为它可以灵活地选择适当的权衡，以最经济的方式实现高可用性和保证性能。  

亚马逊平台上的许多服务**只要求对数据存储的主键访问**。对于这样的服务，使用关系型数据库的常见模式会导致效率低下，并限制可扩展性和可用性。Dynamo 提供了一个简单的只有主键的接口，以满足这些应用程序的要求。  

# 系统应用程序接口
Dynamo 客户端使用 put() 和 get() 操作来写入和读取对应于指定键的数据。这个键唯一地标识了一个对象。  
* get(key) - get 操作找到与给定键相关的对象所在的节点，并返回一个单一的对象或一个具有冲突版本的对象列表以及一个上下文。上下文包含了关于对象的编码元数据，这些元数据对调用者没有意义，包括对象的版本等信息（下面会有更多的介绍）。
* put(key, context, object) - put 操作找到与给定键相关的对象应该被存储的节点，并将给定的对象写到磁盘上。上下文是一个值，通过 get 操作返回，然后通过 put 操作送回。上下文总是与对象一起存储，并像一个 cookie 一样用来验证在投放请求中提供的对象的有效性。

Dynamo 将对象和键都视为一个任意的字节数组（通常小于 1 MB）。它在键上应用 MD5 散列算法，生成一个 128 位的标识符，用来确定负责提供键的存储节点。  



在高层次上，Dynamo 是一个分布式哈希表（DHT），它在集群中进行复制，以实现高可用性和容错。  

介绍。Dynamo的架构#
Dynamo的架构可以概括为以下几点（我们将在下面的课程中详细讨论所有这些概念）。

数据分布#
Dynamo使用一致哈希法在节点间分配数据。一致性散列也使得从Dynamo集群中添加或删除节点变得容易。

数据复制和一致性#
数据是乐观地复制的，即Dynamo提供最终的一致性。

处理临时故障#
为了处理临时故障，Dynamo将数据复制到系统中其他节点的模糊法定人数，而不是严格的多数法定人数。

节点间通信和故障检测#
Dynamo的节点使用gossip协议来跟踪集群状态。

高可用性#
Dynamo通过使用暗示交接使系统 "永远可写"（或高可用性）。

冲突解决和处理永久性故障#
由于没有写入时间保证节点在数值上达成一致，Dynamo使用其他机制来解决潜在冲突。

使用矢量时钟来跟踪值的历史，并在读取时调和不同的历史。
在后台，dynamo使用像Merkle树这样的反熵机制来处理永久性故障。
让我们逐一讨论这些概念。



什么是数据分区？
将数据分布在一组节点上的行为被称为数据分区。当我们试图分配数据时，有两个挑战。
1. 我们如何知道某个特定的数据将被存储在哪个节点上？
2. 当我们添加或删除节点时，我们如何知道哪些数据将从现有的节点转移到新的节点上？此外，当节点加入或离开时，我们怎样才能将数据移动降到最低？

一个天真的方法将是使用一个合适的哈希函数，将数据键映射到一个数字。然后，通过对这个数字和服务器的总数应用模数来找到服务器。比如说。

![](./Data%20partitioning%20through%20simple%20hashing.png)  
通过简单的散列法进行数据分区

上图中描述的方案解决了寻找存储/检索数据的服务器的问题。但是，当我们增加或删除一个服务器时，我们必须重新映射所有的键，并根据新的服务器数量移动数据，这将是一个完全混乱的过程

Dynamo使用一致性散列来解决这些问题。一致性散列算法帮助Dynamo将行映射到物理节点上，也确保在增加或删除服务器时，只有一小部分键会移动。

一致性散列：Dynamo的数据分布＃。
一致性散列将集群管理的数据表示为一个环。环中的每个节点都被分配一个数据范围。Dynamo使用一致散列算法来确定什么行被存储到什么节点。下面是一致散列环的一个例子。

![](./Consistent%20Hashing%20ring.png)  
一致性散列环

通过一致散列，环被划分为更小的预定义范围。每个节点被分配到这些范围中的一个。在Dynamo的术语中，范围的开始被称为token。这意味着每个节点将被分配一个令牌。分配给每个节点的范围是按以下方式计算的。

范围开始。 代币值
范围结束。   下一个令牌值-1

下面是上图中描述的四个节点的令牌和数据范围。
![](./Servers%20and%20token.png)  


每当Dynamo为put()或get()请求提供服务时，它执行的第一个步骤是对键应用MD5散列算法。这个散列算法的输出决定了数据位于哪个范围内，因此，数据将被存储在哪个节点上。正如我们在上面看到的，Dynamo的每个节点都应该存储一个固定范围的数据。因此，从数据键生成的哈希值告诉我们数据将被存储在哪个节点上。下面是一个例子，显示了数据如何在一致哈希环上分布。

![](./Distributing%20data%20on%20the%20consistent%20hashing%20ring.png)  
在一致散列环上分布数据

当一个节点被添加或从环中移除时，上面描述的一致散列方案非常有效；因为在这些情况下，只有下一个节点会受到影响。例如，当一个节点被移除时，下一个节点就会对存储在出站节点上的所有键负责。然而，这种方案会导致数据和负载分布不均匀。Dynamo在虚拟节点的帮助下解决了这些问题。

虚拟节点#
在任何分布式系统中添加和删除节点是很常见的。现有的节点可能会死亡，可能需要退役。同样地，新的节点可能会被添加到现有的集群中，以满足不断增长的需求。Dynamo通过使用虚拟节点（或Vnodes）有效地处理这些情况。

正如我们在上面看到的，基本的一致哈希算法为每个物理节点分配了一个令牌（或一个连续的哈希范围）。这是一种静态的范围划分，需要根据给定的节点数量来计算令牌。这种方案使得添加或替换一个节点成为一个昂贵的操作，因为在这种情况下，我们希望重新平衡并将数据分配给所有其他节点，导致移动大量数据。下面是一些与手动和固定划分范围相关的潜在问题。

* 增加或删除节点。增加或删除节点将导致重新计算令牌，对一个大型集群来说，会造成很大的管理开销。
* 热点。由于每个节点被分配一个大范围，如果数据分布不均匀，一些节点会成为热点。
* 节点重建。由于每个节点的数据被复制在固定数量的节点上（后面会讨论），当我们需要重建一个节点时，只有它的复制节点可以提供数据。这给复制节点带来了很大的压力，并可能导致服务下降。

为了处理这些问题，Dynamo引入了一种新的方案，将令牌分配给物理节点。与其给一个节点分配一个令牌，不如将哈希范围划分为多个较小的范围，每个物理节点被分配到这些较小范围中的多个。这些子范围中的每一个都被称为一个Vnode。有了Vnodes，而不是一个节点只负责一个令牌，而是负责许多令牌（或子范围）。

![](./Comparing%20Consistent%20Hashing%20ring%20with%20and%20without%20Vnodes.png)  
比较有Vnodes和无Vnodes的一致性哈希环

实际上，Vnodes是随机分布在集群中的，通常是不连续的，所以没有两个相邻的Vnodes被分配到同一个物理节点。此外，节点确实携带着其他节点的副本以实现容错。另外，由于集群中可能存在异质机器，一些服务器可能比其他服务器拥有更多的Vnodes。下图显示了物理节点A、B、C、D、E是如何使用一致哈希环的Vnodes的。每个物理节点被分配一组Vnodes，每个Vnode被复制一次。

![](./Mapping%20Vnodes%20to%20physical%20nodes%20on%20a%20Consistent%20Hashing%20ring.png)  
将Vnodes映射到一致哈希环的物理节点上

Vnodes#的优势
Vnodes有以下优点。

1. Vnodes通过将哈希范围划分为较小的子范围，帮助将负载更均匀地分布在集群上的物理节点上。这加快了添加或删除节点后的再平衡过程。当一个新的节点被添加时，它从现有的节点中接收许多Vnodes以保持集群的平衡。同样，当一个节点需要重建时，不是从固定数量的副本中获取数据，而是许多节点参与重建过程。
2. Vnodes使得维护一个包含异构机器的集群变得更加容易。这意味着，有了Vnodes，我们可以给强大的服务器分配较多的范围，给不太强大的服务器分配较少的范围。
3. 由于Vnodes有助于为每个物理节点分配较小的范围，因此出现热点的概率比基本的一致哈希方案要小得多，因为该方案每个节点使用一个大范围。



什么是乐观的复制？
为了确保高可用性和耐久性，Dynamo 将每个数据项复制在多 (N) 个节点上复制每个数据项，其中数值 N 为复制因子，可在 Dynamo 的每个实例中配置。每个键被分配给一个协调者节点（在哈希范围内排在第一位的节点），它首先在本地存储数据，然后将其复制到 N-1 顺时针复制到环上的后续节点。这导致每个节点拥有它和它的第 N 个节点之间的环上的区域第 N 个前辈之间的区域。这种复制是异步进行的（在后台），Dynamo提供了一个最终一致的模型。这种复制技术被称为乐观的复制，这意味着不保证复制在任何时候都是相同的。

![](./Replication%20in%20consistent%20hashing.png)
一致性散列中的复制

Dynamo的每个节点都作为不同范围数据的副本。由于Dynamo存储了N分布在不同节点上的数据副本，如果一个节点发生故障，其他副本可以响应对该范围数据的查询。如果客户端无法联系到协调者节点，它将请求发送到持有副本的节点。

偏好列表
负责存储特定键的节点的列表被称为偏好列表。Dynamo的设计是，系统中的每个节点都可以确定哪些节点应该在这个列表中的任何特定键（后面讨论）。这个列表包含超过N节点，以考虑故障和跳过环上的虚拟节点，这样列表中只包含不同的物理节点。

马虎的法定人数和处理临时故障
按照传统的法定人数方法，任何分布式系统在服务器故障或网络分区时都会变得不可用，即使在简单的故障条件下也会降低可用性。为了提高可用性，Dynamo不执行严格的法定人数要求，而是使用一种叫做 "草率法定人数 "的方法。通过这种方法，所有的读/写操作都在第一个N健康的节点上进行，而这些节点可能并不总是第一个N节点，而这些节点不一定是在一致散列环上顺时针移动时遇到的第一N个节点。

考虑下图中给出的Dynamo配置的例子，N=3. 在这个例子中，如果服务器1在写操作过程中暂时宕机或无法到达，其数据现在将被存储在服务器4上。因此，Dynamo将存储在故障节点（即服务器1）上的副本转移到一致哈希环中没有该副本的下一个节点（即服务器4）。这样做是为了避免由短期机器或网络故障引起的不可用性，并保持所需的可用性和耐久性保证。发送给服务器4的副本在其元数据中会有一个提示，表明哪个节点是该副本的预期接收者（在这种情况下，服务器1）。收到提示副本的节点将把它们保存在一个单独的本地数据库中，并定期进行扫描。在检测到服务器1已经恢复后，服务器4将尝试将副本传递给服务器1。一旦传送成功，服务器4可以从其本地存储中删除该对象，而不减少系统中的副本总数。

![](./Sloppy%20quorum.png)
马虎的法定人数

暗示性的交接
上面描述的提高可用性的有趣技巧被称为暗示性交接，即当一个节点无法到达时，另一个节点可以代表它接受写。然后，写内容被保存在本地缓冲区中，一旦目标节点再次可达，就发送出去。这使得Dynamo "永远可写"。因此，即使在只有一个节点活着的极端情况下，写请求仍然会被接受并最终被处理。

主要的问题是，由于马虎的法定人数不是严格的多数，数据可以而且会出现分歧，也就是说，对同一个键的两个并发写入有可能被不重叠的节点集所接受。这意味着系统中可能存在针对同一键的多个冲突值，我们在读取时可能得到陈旧或冲突的数据。Dynamo允许这种情况，并使用矢量时钟解决这些冲突。



