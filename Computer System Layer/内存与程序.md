内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。  
  
## 内存中的堆栈
内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。  
  
* 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。关于代码程序从编写编译到被执行的过程请参考[程序生命周期](./内存与程序.md#程序生命周期)。
* 静态数据区：存储全局变量、静态变量、常量，常量包括 final 修饰的常量和 String 常量。系统自动分配和回收。
* 动态数据区：
  * 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。栈是一个后进先出 (LIFO) 结构。当把数据放入栈时，把数据 push 进入；当从栈取出数据时，把数据 pop 出来。
      * 例如 int method(int a){int b;} 栈中存储参数 a、局部变量 b、返回值 temp。
      * 例如函数调用的上下文环境（如递归）。
  * 堆区：动态存储器分配，比如 new 一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。由程序员分配和回收（Java 中由 JVM 虚拟机的垃圾回收机制自动回收），否则会发生内存泄漏错误。
      * 例如 Class Student{int num; int age;} main 方法中 Student stu = new Student()；分配堆区空间中存储的该对象的 num、age，变量 stu 存储在栈中，里面的值是对应堆区空间的引用或地址。  
  
另：内存的栈还分系统栈（或称内核栈）和用户栈（用户进程空间的栈），系统栈为操作系统等底层进程程序服务，用户栈为用户进程程序服务。系统栈与用户栈功能类似，系统栈还有一些特殊功能如：中断/优先级处理机制等等。  
  
### 为什么要有堆和栈的区分呢
> 因为结构化语言里函数（子程序）调用最方便的实现方式就是用栈，以至于现在绝大部分芯片都对栈提供芯片级的硬件支持，一条指令即可搞定栈的 pop 操作。栈的好处是：方便、快、有效避免内存碎片化。栈的问题是：不利于管理大内存（尤其在 16 位和 32 位时代）、数据的生命周期难于控制（栈内的有效数据通常是连续存储的，所以 pop 时后申请的内存必须早于先申请的内存失效），所以栈不利于动态地管理并且有效地利用宝贵的内存资源，于是就有了堆，相应的，堆需要一套分配策略以防止出现大量小碎片，栈的分配是编译期决定的，堆的话需要运行时去申请（比如 C 的 malloc），所以堆在调用时没有栈方便，堆在清理时因语言而异，比如 C 没有自动回收则需要手动回收。栈通常是连续的，堆通常是不连续的。性能上，现今 CPU 的处理模型就是栈，栈上的变量命中率比堆高很多。[参考](https://www.zhihu.com/question/49927441)  
  
### 内存分配管理
![](./内存分配管理.jpg)  
  
### 程序生命周期
![](./程序生命周期.jpg)  
  
更多详细可看：  
https://www.jianshu.com/p/52b5a1879aa1  
https://blog.csdn.net/gettogetto/article/details/56487342  
https://blog.csdn.net/yOung_One/article/details/41682167  
  
以上参考：https://www.jianshu.com/p/b42fd8293b4f  
  
## 关于爆栈
> 在写一个算法中，由于递归调用次数过多，堆栈溢出。  
> 堆栈的大小是系统控制的，无法改变。  
> 如果递归调用出现问题，可以考虑采取循环的方式来解决，将需要的数据在关键的调用点保存下来使用。简单的说，就是用自己的数据保存方法来代替系统递归调用产生的堆栈数据。  

> 溢出的意思就是越界，操作系统会给每个进程分配一个最大上限的堆栈空间，如果超过了这个内存空间大小程序就会 coredump，就像你创建一个太大的数组会崩溃一样，因为这里堆溢出了。操作系统分配给一个进程的栈空间是 2M，堆空间在 32 位机器上是 4G。如果你的进程的栈空间使用超过了 2M 就会栈溢出，堆使用超过 4G 就会堆溢出。  

> 那么递归为什么会导致栈溢出呢？相信大家知道栈的出入规则，就像一个瓶子，方法压栈运行，先进后出，递归的话那么先入的不能出栈，会存在栈空间中，这样就容易导致栈满而溢出。  

> 每当你调用一个方法，在这个方法执行前都会将之前的内存地址（也就是调用点）入栈，等被调用的方法执行完将地址出栈，程序根据这个数据返回调用点。  
> 若递归调用次数太多，就会只入栈不出栈，于是堆栈就被压爆了，此为栈溢出。  

> 递归函数调用的太深，需要太多的内存，递归里用到的局部变量存储在堆栈中，堆栈的访问效率高，速度快，但空间有限，递归太多变量需要一直入栈而不出栈，导致需要的内存空间大于堆栈的空间。  

原文链接：https://blog.csdn.net/qq_42370146/article/details/82356792  
