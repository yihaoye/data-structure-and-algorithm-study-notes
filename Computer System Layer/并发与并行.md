# 并发与并行
  
## 并发（Concurrency）
同时完成多任务。无需等待当前任务完成即可执行其他任务。“并发”解决了程序因外部控制而无法进一步执行的阻塞问题。最常见的例子就是 I/O 操作，任务必须等待数据输入（在一些例子中也称阻塞）。这个问题常见于 I/O 密集型任务。  
并发通常可以提高在单处理器上运行的程序的性能。这听起来有点违反直觉。如果你仔细想想，由于上下文切换的成本增加（从一个任务切换到另一个任务），在单个处理器上运行的并发程序实际上应该比程序的所有部分顺序运行具有更多的开销。从表面上看，将程序的所有部分作为单个任务运行，并且节省上下文切换的成本，这样看似乎更划算。  
使这个问题变得有些不同的是阻塞。如果程序中的某个任务由于程序控制之外的某种情况而无法继续（通常是 I/O），我们就称该任务或线程已阻塞（在我们的科幻故事中，就是克隆人已经敲门并等待它打开）。如果没有并发，整个程序就会停下来，直到外部条件发生变化。但是，如果使用并发编写程序，则当一个任务被阻塞时，程序中的其他任务可以继续执行，因此整个程序得以继续运行。事实上，从性能的角度来看，如果没有任务会阻塞，那么在单处理器机器上使用并发是没有意义的。  
  
## 并行（Parallel）
同时在多个位置完成多任务。这解决了所谓的 CPU 密集型问题：将程序分为多部分，在多个处理器上同时处理不同部分来加快程序执行效率。  
通常即指多线程或多核处理。某种程度上可以认为并行是并发的子集，因为并发既有单核实现也有多核实现。  
  
## 总结
上面的定义说明了这两个术语令人困惑的原因：两者的核心都是“同时完成多个任务”，不过并行增加了跨多个处理器的分布。更重要的是，它们可以解决不同类型的问题：并行可能对解决 I / O 密集型问题没有任何好处，因为问题不在于程序的整体执行速度，而在于 I/O 阻塞。而尝试在单个处理器上使用并发来解决计算密集型问题也可能是浪费时间。两种方法都试图在更短的时间内完成更多工作，但是它们实现加速的方式有所不同，这取决于问题施加的约束。  
这两个概念混合在一起的一个主要原因是包括 Java 在内的许多编程语言使用相同的机制 - 线程来实现并发和并行。  
可以尝试以更细的粒度去进行定义（然而这并不是标准化的术语）：  
* 纯并发：仍然在单个 CPU 上运行任务。纯并发系统比顺序系统更快地产生结果，但是它的运行速度不会因为处理器的增加而变得更快。
* 并发-并行：使用并发技术，结果程序可以利用更多处理器更快地产生结果。
* 并行-并发：使用并行编程技术编写，如果只有一个处理器，结果程序仍然可以运行（Java 8 Streams 就是一个很好的例子）。
* 纯并行：除非有多个处理器，否则不会运行。  
  
## Java 并发四句格言
1. 不要用它（避免使用并发）
2. 没有什么是真的，一切可能都有问题
3. 仅仅是它能运行，并不意味着它没有问题
4. 你必须理解它（逃不掉并发）  
  
## 并发并行与异步的区别
[参考](./异步与同步.md#异步与并发并行的区别)  
  
## 多线程的时间复杂度
《算法导论》里面有提过，多线程的运行效率不是以时间复杂度来衡量，而是用了 “工作量（work）” 以及 “持续时间（span）” 两个维度来进行计算：  
* “工作量” 可以理解为一般理解的时间复杂度（一共总共有多少步需要完成）。
* “持续时间” 这个比较复杂，可以理解为某个子问题需要花的最长时间，也就是即使有多个处理器的前提下，整个算法最少需要花费的时间。
  
## 更多参考
[Playlist: Java Concurrency and Multithreading](https://www.youtube.com/watch?v=mTGdtC9f4EU&list=PLL8woMHwr36EDxjUoCzboZjedsnhLP1j4)  
以上视频[源代码](./并发与并行(Java)/Jenkov/)  
